<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Recipe Manager Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
    />
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"
      xintegrity="sha512-GsLlZN/3F2ErC5ifS5QtgpiJtWd43JWSuIgh7mbzZ8zBps+dvLusV+eNQATqgA/HdeKFVgA5v3S/cIrLF7QnIg=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
    <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.24.0/babel.min.js"></script>
    <style>
      /* Custom scrollbar for better aesthetics */
      ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      ::-webkit-scrollbar-track {
        background: #f0f0f0;
        border-radius: 10px;
      }
      ::-webkit-scrollbar-thumb {
        background: #ccc;
        border-radius: 10px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #999;
      }
      /* Dark mode scrollbar */
      .dark ::-webkit-scrollbar-track {
        background: #2d3748; /* dark gray */
      }
      .dark ::-webkit-scrollbar-thumb {
        background: #4a5568; /* darker gray */
      }
      .dark ::-webkit-scrollbar-thumb:hover {
        background: #6a7788;
      }

      /* Prevent body scroll when modal is open */
      body.modal-open {
        overflow: hidden;
      }

      /* Toast Animation */
      @keyframes fadeInOut {
        0% {
          opacity: 0;
          transform: translateY(10px);
        }
        15% {
          opacity: 1;
          transform: translateY(0);
        }
        85% {
          opacity: 1;
          transform: translateY(0);
        }
        100% {
          opacity: 0;
          transform: translateY(10px);
        }
      }
      .animate-fade-in-out {
        animation: fadeInOut 3s ease-in-out forwards;
      }

      /* Modal Animation */
      @keyframes scaleIn {
        from {
          transform: scale(0.95);
          opacity: 0;
        }
        to {
          transform: scale(1);
          opacity: 1;
        }
      }
      .modal-scale-enter {
        animation: scaleIn 0.2s ease-out forwards;
      }

      /* Collapsible Section Animation */
      .collapsible-content {
        transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
        overflow: hidden;
        max-height: 0;
        opacity: 0;
      }
      .collapsible-content.expanded {
        max-height: 1000px; /* Adjust as needed */
        opacity: 1;
      }

      /* Custom Button Styles (Header) */
      .btn-header {
        background-color: #f3f4f6; /* gray-100 */
        color: #374151; /* gray-700 */
        padding: 6px 10px;
        border-radius: 9999px; /* pill shape */
        display: inline-flex;
        align-items: center;
        font-size: 0.875rem; /* text-sm */
        transition: background-color 0.2s ease, color 0.2s ease;
        border: 1px solid transparent;
        white-space: nowrap; /* Prevent wrapping */
      }
      .btn-header:hover {
        background-color: #e5e7eb; /* gray-200 */
      }
      .dark .btn-header {
        background-color: #374151; /* gray-700 */
        color: #d1d5db; /* gray-300 */
      }
      .dark .btn-header:hover {
        background-color: #4b5563; /* gray-600 */
      }
      /* Specific override for green button */
      .btn-header.bg-green-500 {
        border-color: transparent;
        color: white; /* Ensure text is white on green bg */
      }
      .dark .btn-header.bg-green-500 {
        color: white; /* Keep white text in dark mode too */
      }

      /* Custom Filter Select Styles */
      .filter-select {
        padding: 4px 8px;
        border-radius: 6px;
        border: 1px solid #d1d5db; /* gray-300 */
        background-color: #ffffff; /* white */
        color: #1f2937; /* gray-800 */
        font-size: 0.875rem; /* text-sm */
        line-height: 1.25rem;
        appearance: none; /* Remove default arrow */
        /* Custom arrow using SVG */
        background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2220%22%20height%3D%2220%22%20fill%3D%22none%22%20stroke%3D%22%236b7280%22%20stroke-linecap%3D%22round%22%20stroke-linejoin%3D%22round%22%20stroke-width%3D%221.5%22%20viewBox%3D%220%200%2024%2024%22%3E%3Cpath%20d%3D%22M6%209l6%206%206-6%22%2F%3E%3C%2Fsvg%3E");
        background-repeat: no-repeat;
        background-position: right 0.5rem center;
        background-size: 1em 1em;
        padding-right: 2rem; /* Space for the arrow */
      }
      .dark .filter-select {
        border-color: #4b5563; /* gray-600 */
        background-color: #374151; /* gray-700 */
        color: #f3f4f6; /* gray-100 */
        /* Dark mode arrow */
        background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2220%22%20height%3D%2220%22%20fill%3D%22none%22%20stroke%3D%22%23d1d5db%22%20stroke-linecap%3D%22round%22%20stroke-linejoin%3D%22round%22%20stroke-width%3D%221.5%22%20viewBox%3D%220%200%2024%2024%22%3E%3Cpath%20d%3D%22M6%209l6%206%206-6%22%2F%3E%3C%2Fsvg%3E");
      }
      .filter-select:focus {
        outline: none;
        border-color: #10b981; /* emerald-500 */
        box-shadow: 0 0 0 1px #10b981;
      }

      /* Custom Modal Input/Textarea Styles */
      .modal-input,
      .modal-textarea,
      .modal-input-sm {
        width: 100%;
        border-radius: 0.375rem; /* rounded-md */
        border: 1px solid #d1d5db; /* gray-300 */
        background-color: #f9fafb; /* gray-50 */
        color: #111827; /* gray-900 */
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
      }
      .modal-input,
      .modal-textarea {
        padding: 8px 12px; /* py-2 px-3 */
      }
      .modal-input-sm {
        padding: 6px 10px; /* Smaller padding */
        font-size: 0.875rem; /* text-sm */
      }
      .dark .modal-input,
      .dark .modal-textarea,
      .dark .modal-input-sm {
        border-color: #4b5563; /* gray-600 */
        background-color: #374151; /* gray-700 */
        color: #f3f4f6; /* gray-100 */
      }
      .modal-input:focus,
      .modal-textarea:focus,
      .modal-input-sm:focus {
        outline: none;
        border-color: #10b981; /* emerald-500 */
        box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.3); /* Focus ring */
      }
      /* Error state */
      .modal-input.border-red-500,
      .modal-textarea.border-red-500,
      .modal-input-sm.border-red-500 {
        border-color: #ef4444; /* red-500 */
      }
      .modal-input.border-red-500:focus,
      .modal-textarea.border-red-500:focus,
      .modal-input-sm.border-red-500:focus {
        box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.3); /* Red focus ring */
      }

      /* Custom Modal Button Styles */
      .btn-modal {
        padding: 6px 12px; /* py-1.5 px-3 */
        border-radius: 6px; /* rounded-md */
        font-size: 0.875rem; /* text-sm */
        display: inline-flex;
        align-items: center;
        transition: all 0.2s ease;
        border: none;
        cursor: pointer;
      }
      .btn-modal:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .btn-green {
        background-color: #10b981; /* emerald-500 */
        color: white;
      }
      .btn-green:hover:not(:disabled) {
        background-color: #059669; /* emerald-600 */
      }
      .btn-gray {
        background-color: #e5e7eb; /* gray-200 */
        color: #1f2937; /* gray-800 */
      }
      .btn-gray:hover:not(:disabled) {
        background-color: #d1d5db; /* gray-300 */
      }
      .dark .btn-gray {
        background-color: #4b5563; /* gray-600 */
        color: #e5e7eb; /* gray-200 */
      }
      .dark .btn-gray:hover:not(:disabled) {
        background-color: #6b7280; /* gray-500 */
      }
      .btn-blue {
        background-color: #3b82f6; /* blue-500 */
        color: white;
      }
      .btn-blue:hover:not(:disabled) {
        background-color: #2563eb; /* blue-600 */
      }
      .btn-red {
        background-color: #ef4444; /* red-500 */
        color: white;
      }
      .btn-red:hover:not(:disabled) {
        background-color: #dc2626; /* red-600 */
      }

      /* Servings Adjust Button Styles */
      .adjust-btn {
        background-color: #d1d5db; /* gray-300 */
        color: #374151; /* gray-700 */
        width: 1.75rem; /* w-7 */
        height: 1.75rem; /* h-7 */
        border-radius: 9999px; /* rounded-full */
        font-size: 1rem;
        line-height: 1;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border: none;
        cursor: pointer;
        transition: background-color 0.2s ease;
      }
      .adjust-btn:hover:not(:disabled) {
        background-color: #9ca3af; /* gray-400 */
      }
      .adjust-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .dark .adjust-btn {
        background-color: #4b5563; /* gray-600 */
        color: #e5e7eb; /* gray-200 */
      }
      .dark .adjust-btn:hover:not(:disabled) {
        background-color: #6b7280; /* gray-500 */
      }

      /* Line Clamp Utilities */
      .line-clamp-1 {
        overflow: hidden;
        display: -webkit-box;
        -webkit-box-orient: vertical;
        -webkit-line-clamp: 1;
      }
      .line-clamp-2 {
        overflow: hidden;
        display: -webkit-box;
        -webkit-box-orient: vertical;
        -webkit-line-clamp: 2;
      }
      .line-clamp-3 {
        overflow: hidden;
        display: -webkit-box;
        -webkit-box-orient: vertical;
        -webkit-line-clamp: 3;
      }

      /* Utility Classes (Consider replacing with Tailwind if possible) */
      .tc {
        text-align: center;
      }
      .op-70 {
        opacity: 0.7;
      }
      .op-80 {
        opacity: 0.8;
      }
      .op-50 {
        opacity: 0.5;
      }
      .mr-0\.5 {
        margin-right: 0.125rem;
      }

      /* Tag Input Styles */
      .tag-input-container {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        padding: 4px;
        border: 1px solid #d1d5db; /* gray-300 */
        border-radius: 0.375rem; /* rounded-md */
        background-color: #f9fafb; /* gray-50 */
        min-height: 38px; /* Match input height */
      }
      .dark .tag-input-container {
        border-color: #4b5563; /* gray-600 */
        background-color: #374151; /* gray-700 */
      }
      .tag-item {
        background-color: #10b981; /* emerald-500 */
        color: white;
        padding: 2px 8px;
        border-radius: 9999px; /* rounded-full */
        font-size: 0.875rem; /* text-sm */
        margin: 2px;
        display: inline-flex;
        align-items: center;
        white-space: nowrap;
      }
      .tag-item-remove {
        background: none;
        border: none;
        color: white;
        margin-left: 4px;
        cursor: pointer;
        font-size: 0.75rem; /* text-xs */
        opacity: 0.7;
        transition: opacity 0.2s;
      }
      .tag-item-remove:hover {
        opacity: 1;
      }
      .tag-input {
        flex-grow: 1;
        border: none;
        outline: none;
        padding: 6px 8px;
        background-color: transparent;
        color: #111827; /* gray-900 */
        min-width: 100px;
      }
      .dark .tag-input {
        color: #f3f4f6; /* gray-100 */
      }
      .tag-input-container:focus-within {
        border-color: #10b981; /* emerald-500 */
        box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.3); /* Focus ring */
      }
      /* Apply error border to container if needed (example) */
      .tag-input-container.border-red-500 {
        border-color: #ef4444;
      }
    </style>
  </head>
  <body
    class="bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-100 transition-colors duration-300 font-sans"
  >
    <div id="root"></div>

    <script type="text/babel">
      // Destructure React hooks for easier use
      const { useState, useEffect, useRef, useMemo, useCallback } = React;

      // Constants for local storage keys
      const STORAGE_KEYS = {
        RECIPES: "recipes",
        MEAL_PLAN: "mealPlan",
        SHOPPING_LIST: "shoppingList",
        THEME: "theme", // Keep theme key for initial dark mode detection
      };

      // Utility to convert total minutes to hours and minutes string
      const formatMinutesToHoursMinutes = (totalMinutes) => {
        if (isNaN(totalMinutes) || totalMinutes < 0) return "";
        const hours = Math.floor(totalMinutes / 60);
        const minutes = totalMinutes % 60;
        let parts = [];
        if (hours > 0) parts.push(`${hours}h`);
        if (minutes > 0 || totalMinutes === 0) parts.push(`${minutes}m`); // Always show minutes if 0, or if there are minutes
        return parts.join(" ");
      };

      // Basic HTML escaping function
      const escapeHTML = (str) => {
        if (!str) return "";
        return str
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
      };

      // Parses an ingredient string into quantity and the rest of the text
      const parseIngredient = (ingredient) => {
        if (typeof ingredient !== "string") return { quantity: null, rest: "" };
        // Regex to capture leading quantity/unit and the rest
        // Handles numbers, fractions (e.g., 1/2, 1 1/2), decimals, unicode fractions, and common units
        const regex =
          /^([\d./\s½¼¾⅓⅔⅛⅜⅝⅞]+(?:\s*(?:tbsp|tsp|cup|oz|lb|g|kg|ml|l|cloves?|cans?|jars?|slices?|pinch|dash|stalks?|heads?|sprigs?|bunch|packages?|pkg|box|containers?|sticks?|pieces?|fillets?|ears?))?)?\s*(.*)/i;
        const match = ingredient.match(regex);

        if (match) {
          let quantity = null;
          const quantityString = match[1]?.trim();
          let rest = match[2]?.trim();

          if (quantityString) {
            try {
              // Further split quantity string into numeric part and potential unit
              const qtyUnitRegex = /([\d./\s½¼¾⅓⅔⅛⅜⅝⅞]+)\s*([a-z]+)?$/i;
              const qtyUnitMatch = quantityString.match(qtyUnitRegex);
              let numericPart = quantityString;
              let unitPart = "";

              if (qtyUnitMatch) {
                numericPart = qtyUnitMatch[1]?.trim();
                unitPart = qtyUnitMatch[2] ? ` ${qtyUnitMatch[2]}` : "";
                // If unit was captured but not present in the 'rest', prepend it back
                if (
                  unitPart &&
                  !rest.toLowerCase().includes(unitPart.trim().toLowerCase())
                ) {
                  rest = `${unitPart.trim()} ${rest}`.trim();
                }
              }

              // Handle mixed numbers (e.g., "1 1/2") and simple additions ("1 + 1/2")
              const mixedParts = numericPart.split(/[\s\+]+/);
              let totalQuantity = 0;
              const unicodeFractions = {
                "½": 0.5,
                "¼": 0.25,
                "¾": 0.75,
                "⅓": 1 / 3,
                "⅔": 2 / 3,
                "⅛": 1 / 8,
                "⅜": 3 / 8,
                "⅝": 5 / 8,
                "⅞": 7 / 8,
              };

              for (const part of mixedParts) {
                if (part.includes("/")) {
                  // Handle fractions like "1/2"
                  const fractionParts = part.split("/");
                  if (fractionParts.length === 2) {
                    const num = parseFloat(fractionParts[0]);
                    const den = parseFloat(fractionParts[1]);
                    if (!isNaN(num) && !isNaN(den) && den !== 0)
                      totalQuantity += num / den;
                    else throw new Error("Invalid fraction part");
                  } else throw new Error("Invalid fraction format");
                } else if (unicodeFractions[part]) {
                  // Handle unicode fractions
                  totalQuantity += unicodeFractions[part];
                } else {
                  // Handle whole numbers or decimals
                  const num = parseFloat(part);
                  if (!isNaN(num)) totalQuantity += num;
                  else throw new Error("Invalid numeric part");
                }
              }
              quantity = totalQuantity > 0 ? totalQuantity : null;
            } catch (e) {
              console.warn("Could not parse quantity:", quantityString, e);
              quantity = null;
              rest = ingredient; // Revert to original if parsing fails
            }
          }
          return { quantity, rest };
        }
        // If no quantity match, return the whole string as 'rest'
        return { quantity: null, rest: ingredient };
      };

      // Formats a numeric quantity into a readable string (e.g., 1.5 -> "1 ½")
      const formatQuantity = (quantity) => {
        if (quantity === null || quantity === undefined || isNaN(quantity))
          return "";
        if (quantity === 0) return "";

        // Simple whole number
        if (quantity % 1 === 0) return quantity.toString();

        const tolerance = 0.01; // Tolerance for matching decimal to fraction
        const fractions = [
          { decimal: 1 / 8, fraction: "⅛" },
          { decimal: 1 / 4, fraction: "¼" },
          { decimal: 1 / 3, fraction: "⅓" },
          { decimal: 3 / 8, fraction: "⅜" },
          { decimal: 1 / 2, fraction: "½" },
          { decimal: 5 / 8, fraction: "⅝" },
          { decimal: 2 / 3, fraction: "⅔" },
          { decimal: 3 / 4, fraction: "¾" },
          { decimal: 7 / 8, fraction: "⅞" },
        ].sort((a, b) => a.decimal - b.decimal); // Sort for predictable matching

        const whole = Math.floor(quantity);
        const decimalPart = quantity - whole;

        // Find the closest fraction within tolerance
        for (let f of fractions) {
          if (Math.abs(decimalPart - f.decimal) < tolerance) {
            return whole > 0 ? `${whole} ${f.fraction}` : f.fraction;
          }
        }

        // Fallback to decimal if no close fraction found
        return parseFloat(quantity.toFixed(2)).toString();
      };

      // New Utility: Parses a yield string into quantity and unit
      const parseYield = (yieldString) => {
        if (typeof yieldString !== "string" || yieldString.trim() === "")
          return { quantity: null, unit: "" };

        // Regex to capture numeric part and the rest as unit
        // Example: "8 servings", "1.5 cups", "2 loins"
        const match = yieldString.trim().match(/^([\d./\s½¼¾⅓⅔⅛⅜⅝⅞]+)\s*(.*)/i);
        if (match) {
          const numericPart = match[1]?.trim();
          const unitPart = match[2]?.trim() || "";
          try {
            const mixedParts = numericPart.split(/[\s\+]+/);
            let totalQuantity = 0;
            const unicodeFractions = {
              "½": 0.5,
              "¼": 0.25,
              "¾": 0.75,
              "⅓": 1 / 3,
              "⅔": 2 / 3,
              "⅛": 1 / 8,
              "⅜": 3 / 8,
              "⅝": 5 / 8,
              "⅞": 7 / 8,
            };

            for (const part of mixedParts) {
              if (part.includes("/")) {
                const fractionParts = part.split("/");
                if (fractionParts.length === 2) {
                  const num = parseFloat(fractionParts[0]);
                  const den = parseFloat(fractionParts[1]);
                  if (!isNaN(num) && !isNaN(den) && den !== 0)
                    totalQuantity += num / den;
                  else throw new Error("Invalid fraction part");
                } else throw new Error("Invalid fraction format");
              } else if (unicodeFractions[part]) {
                totalQuantity += unicodeFractions[part];
              } else {
                const num = parseFloat(part);
                if (!isNaN(num)) totalQuantity += num;
                else throw new Error("Invalid numeric part");
              }
            }
            return { quantity: totalQuantity, unit: unitPart };
          } catch (e) {
            console.warn("Could not parse yield quantity:", numericPart, e);
            return { quantity: null, unit: yieldString.trim() }; // Return original string as unit if quantity parsing fails
          }
        }
        return { quantity: null, unit: yieldString.trim() }; // No numeric part, return whole string as unit
      };

      // New Utility: Formats scaled yield based on multiplier
      const formatScaledYield = (originalYieldString, multiplier) => {
        if (
          multiplier === 1 ||
          !originalYieldString ||
          originalYieldString.trim() === ""
        ) {
          return originalYieldString; // No scaling needed
        }

        const { quantity, unit } = parseYield(originalYieldString);

        if (quantity === null || quantity === 0) {
          return originalYieldString; // Cannot scale if no quantity or quantity is zero
        }

        const scaledQuantity = quantity * multiplier;

        // Handle pluralization for common units, if possible
        let formattedUnit = unit;
        if (
          scaledQuantity > 1 &&
          unit &&
          !unit.endsWith("s") &&
          !unit.endsWith("es")
        ) {
          // Simple pluralization for common cases like 'cup' -> 'cups', 'serving' -> 'servings'
          if (
            ["cup", "serving", "loin", "piece"].includes(unit.toLowerCase())
          ) {
            formattedUnit = unit + "s";
          }
        } else if (
          scaledQuantity <= 1 &&
          unit &&
          (unit.endsWith("s") || unit.endsWith("es"))
        ) {
          // Simple de-pluralization (e.g., if "2 cups" becomes "0.5 cup")
          if (
            ["cups", "servings", "loins", "pieces"].includes(unit.toLowerCase())
          ) {
            formattedUnit = unit.slice(0, -1); // Remove 's'
          } else if (["batches", "washes"].includes(unit.toLowerCase())) {
            // handles 'es'
            formattedUnit = unit.slice(0, -2);
          }
        }

        return `${formatQuantity(scaledQuantity)} ${formattedUnit}`.trim();
      };

      // Normalizes ingredient text for comparison (e.g., in shopping list)
      const normalizeIngredient = (ingredient) => {
        // First, extract the main ingredient name part
        const { rest } = parseIngredient(ingredient);
        if (!rest) return "";

        // Define lists of common units and descriptors to remove
        const units = [
          "tbsp",
          "tablespoon",
          "tbs",
          "tsp",
          "teaspoon",
          "cup",
          "c",
          "oz",
          "ounce",
          "fl oz",
          "fluid ounce",
          "pt",
          "pint",
          "qt",
          "quart",
          "gal",
          "gallon",
          "lb",
          "pound",
          "g",
          "gram",
          "kg",
          "kilogram",
          "mg",
          "milligram",
          "ml",
          "milliliter",
          "l",
          "liter",
          "clove",
          "can",
          "jar",
          "slice",
          "pinch",
          "dash",
          "stalk",
          "head",
          "sprig",
          "bunch",
          "package",
          "pkg",
          "box",
          "container",
          "stick",
          "piece",
          "fillet",
          "ear",
        ];
        const descriptors = [
          "to taste",
          "diced",
          "minced",
          "sliced",
          "chopped",
          "crushed",
          "fresh",
          "for garnish",
          "finely",
          "roughly",
          "peeled",
          "seeded",
          "cored",
          "rinsed",
          "dried",
          "optional",
          "divided",
          "softened",
          "melted",
          "beaten",
          "cooked",
          "uncooked",
          "raw",
          "canned",
          "frozen",
          "thawed",
          "packed",
          "firmly packed",
          "lightly packed",
          "heaping",
          "scant",
          "large",
          "medium",
          "small",
          "thinly",
          "thickly",
          "cubed",
          "julienned",
          "grated",
          "zested",
          "juiced",
          "room temperature",
          "cold",
          "hot",
          "warm",
          "about",
          "approximately",
          "plus more",
          "or more",
          "as needed",
          "such as",
        ];

        // Process the string: lowercase, remove parentheses, units, descriptors, punctuation, extra spaces
        let normalized = rest
          .toLowerCase()
          .replace(/\(.*?\)/g, "") // Remove content in parentheses
          .replace(new RegExp(`\\b(${units.join("|")})s?\\b`, "g"), "") // Remove units (and plural 's')
          .replace(new RegExp(`\\b(${descriptors.join("|")})\\b`, "g"), "") // Remove descriptors
          .replace(/[^a-z\s]/g, "") // Remove non-alpha characters (except spaces)
          .replace(/\s+/g, " ") // Collapse multiple spaces
          .trim();

        // Basic pluralization removal (handle common cases like 'es' and 's')
        if (
          normalized.endsWith("es") &&
          ["tomato", "potato"].some((base) => normalized.startsWith(base))
        ) {
          normalized = normalized.slice(0, -2);
        } else if (
          normalized.endsWith("s") &&
          !normalized.endsWith("ss") && // Avoid words like 'greenss' -> 'green'
          !["greens", "oats", "pasta", "rice", "hummus", "molasses"].includes(
            normalized
          ) && // Exclude known plurals/uncountables
          normalized.length > 2
        ) {
          normalized = normalized.slice(0, -1);
        }

        return normalized;
      };

      // Capitalizes the first letter of a string
      const capitalizeFirstLetter = (string) => {
        if (!string) return "";
        return string.charAt(0).toUpperCase() + string.slice(1);
      };

      // Sample data for initial state (if local storage is empty)
      const SAMPLE_RECIPES = [
        {
          id: "1",
          name: "Classic Spaghetti Bolognese",
          description:
            "A rich and hearty meat sauce simmered slowly and served over pasta. Comfort food at its best.",
          type: "Dinner",
          dietaryTypes: ["Dairy-Free"],
          tags: ["Weeknight", "Comfort Food"],
          prepTime: 20, // Stored in minutes
          cookTime: 40, // Stored in minutes
          additionalTime: 0,
          calories: 650,
          protein: 32,
          carbs: 78,
          fat: 22,
          servings: 4,
          yield: "4 servings", // Added yield
          ingredients: [
            "1 lb ground beef",
            "1 onion, diced",
            "3 cloves garlic, minced",
            "2 cans (14 oz each) crushed tomatoes",
            "1 lb spaghetti",
            "2 tbsp olive oil",
            "Salt and Pepper to taste",
            "Fresh basil for garnish",
          ],
          directions: [
            "Heat olive oil in a large pot over medium heat.",
            "Add onions and garlic, sauté until translucent.",
            "Add ground beef and cook until browned.",
            "Pour in crushed tomatoes and seasonings.",
            "Simmer for 30 minutes.",
            "Cook spaghetti according to package directions.",
            "Serve sauce over pasta with fresh basil.",
          ],
          tipsAndTricks: [
            "For a vegetarian version, substitute ground beef with lentils or mushrooms.",
            "Add a splash of red wine to the sauce for extra depth of flavor.",
          ],
          createdAt: new Date(Date.now() - 86400000 * 2).toISOString(), // 2 days ago
          isFavorite: false,
          image: null, // Placeholder for image data URL or external URL
          video: null, // Placeholder for video data URL or external URL
        },
        {
          id: "2",
          name: "Quick Garden Salad",
          description:
            "A light and refreshing salad, perfect for a quick lunch or side dish. Easily customizable.",
          type: "Lunch",
          dietaryTypes: ["Vegan", "Gluten-Free"],
          tags: ["Quick", "Healthy", "Vegan"],
          prepTime: 15,
          cookTime: 0,
          additionalTime: 0,
          calories: 200,
          protein: 5,
          carbs: 20,
          fat: 12,
          servings: 2,
          yield: "1 large bowl", // Added yield
          ingredients: [
            "2 cups mixed greens",
            "1 tomato, diced",
            "1/2 red onion, sliced",
            "1 cucumber, sliced",
            "2 tbsp olive oil",
            "1 tbsp balsamic vinegar",
            "Salt and pepper to taste",
          ],
          directions: [
            "Combine greens, tomato, onion, and cucumber in a bowl.",
            "Drizzle with olive oil and balsamic vinegar.",
            "Season with salt and pepper.",
            "Toss and serve immediately.",
          ],
          tipsAndTricks: [
            "Add some toasted nuts or seeds for extra crunch and protein.",
            "For a creamier dressing, mix in a teaspoon of Dijon mustard.",
          ],
          createdAt: new Date(Date.now() - 86400000).toISOString(), // 1 day ago
          isFavorite: true,
          image: null,
          video: null,
        },
        {
          id: "3",
          name: "Simple Beef Burgers",
          description:
            "Juicy, classic beef burgers perfect for grilling or pan-frying. A crowd-plEaser for any occasion.",
          type: "Dinner",
          dietaryTypes: [],
          tags: ["Grill", "Quick", "Kid-Friendly"],
          prepTime: 10,
          cookTime: 15,
          additionalTime: 5, // Resting time
          calories: 550,
          protein: 30,
          carbs: 35,
          fat: 30,
          servings: 4,
          yield: "4 burgers", // Added yield
          ingredients: [
            "1 lb ground beef",
            "1 tsp garlic powder",
            "1/2 tsp salt",
            "1/4 tsp black pepper",
            "4 burger buns",
            "Lettuce, tomato, onion slices (optional toppings)",
            "3 cloves garlic", // Note: Duplicate garlic, might be intentional or typo in original data
          ],
          directions: [
            "Preheat grill or pan.",
            "Gently mix ground beef, garlic powder, salt, and pepper. Do not overmix.",
            "Form into 4 patties.",
            "Grill or pan-fry for 4-6 minutes per side for medium, or longer depending on desired doneness.",
            "Let rest for 5 minutes.",
            "Serve on buns with desired toppings.",
          ],
          tipsAndTricks: [
            "For juicier burgers, mix in 1/4 cup of grated onion or breadcrumbs soaked in milk.",
            "Make a small indentation in the center of each patty before cooking to prevent bulging.",
          ],
          createdAt: new Date().toISOString(), // Today
          isFavorite: false,
          image: null,
          video: null,
        },
      ];

      // --- Custom Hooks ---

      // Hook for managing state persistence in local storage
      const useLocalStorage = (key, initialValue) => {
        // Get stored value or initial value
        const [storedValue, setStoredValue] = useState(() => {
          try {
            const item = window.localStorage.getItem(key);
            // Special handling for recipes to ensure defaults
            if (key === STORAGE_KEYS.RECIPES && item) {
              const parsed = JSON.parse(item);
              if (Array.isArray(parsed)) {
                return parsed.map((recipe) => ({
                  ...recipe,
                  tags: recipe.tags || [], // Ensure tags array exists
                  description: recipe.description || "", // Ensure description exists
                  dietaryTypes: recipe.dietaryTypes || [], // Ensure dietaryTypes exists
                  ingredients: recipe.ingredients || [], // Ensure ingredients exists
                  directions: recipe.directions || [], // Ensure directions exists
                  tipsAndTricks: recipe.tipsAndTricks || [], // Ensure tipsAndTricks exists
                  yield: recipe.yield || "", // Ensure yield exists
                }));
              }
            }
            // For other keys or if recipes parsing failed, use standard logic
            return item ? JSON.parse(item) : initialValue;
          } catch (error) {
            console.error(`Error reading localStorage key “${key}”:`, error);
            // If error reading, remove the faulty item and return initial value
            window.localStorage.removeItem(key);
            // Ensure initial recipes have defaults too
            if (key === STORAGE_KEYS.RECIPES && Array.isArray(initialValue)) {
              return initialValue.map((recipe) => ({
                ...recipe,
                tags: recipe.tags || [],
                description: recipe.description || "",
                dietaryTypes: recipe.dietaryTypes || [],
                ingredients: recipe.ingredients || [],
                directions: recipe.directions || [],
                tipsAndTricks: recipe.tipsAndTricks || [],
                yield: recipe.yield || "",
              }));
            }
            return initialValue;
          }
        });

        // Function to update state and local storage
        const setValue = useCallback(
          (value) => {
            try {
              // Allow value to be a function (like setState)
              const valueToStore =
                value instanceof Function ? value(storedValue) : value;
              setStoredValue(valueToStore);
              window.localStorage.setItem(key, JSON.stringify(valueToStore));
            } catch (error) {
              console.error(`Error setting localStorage key “${key}”:`, error);
            }
          },
          [key, storedValue] // Include storedValue in dependency array for the function version of setValue
        );

        return [storedValue, setValue];
      };

      // --- Components ---

      // Toast notification component
      const Toast = ({ message, type, onClose }) => {
        // Automatically close after 3 seconds
        useEffect(() => {
          const timer = setTimeout(onClose, 3000);
          return () => clearTimeout(timer); // Cleanup timer on unmount
        }, [onClose]);

        // Determine background color based on type
        const bgColor =
          type === "success"
            ? "bg-green-500"
            : type === "error"
            ? "bg-red-500"
            : "bg-blue-500"; // Default to blue for 'info'

        return (
          <div
            className={`p-3 rounded-lg shadow-lg text-white text-sm ${bgColor} animate-fade-in-out`}
          >
            {message}
          </div>
        );
      };

      // Main Application Component
      const App = () => {
        // --- State ---
        // Core data states using local storage hook
        const [recipes, setRecipes] = useLocalStorage(
          STORAGE_KEYS.RECIPES,
          SAMPLE_RECIPES.map((r) => ({
            // Ensure sample recipes also have defaults
            ...r,
            tags: r.tags || [],
            description: r.description || "",
            dietaryTypes: r.dietaryTypes || [],
            ingredients: r.ingredients || [],
            directions: r.directions || [],
            tipsAndTricks: r.tipsAndTricks || [],
            yield: r.yield || "",
          }))
        );
        const [mealPlan, setMealPlan] = useLocalStorage(
          STORAGE_KEYS.MEAL_PLAN,
          {} // Initial empty meal plan
        );
        const [shoppingList, setShoppingList] = useLocalStorage(
          STORAGE_KEYS.SHOPPING_LIST,
          [] // Initial empty shopping list
        );

        // UI State
        // We will default to dark mode based on system preference and remove the toggle
        const [isDarkMode, setIsDarkMode] = useState(() => {
          // No longer store theme in local storage via toggle, just detect system preference
          return (
            typeof window.matchMedia === "function" &&
            window.matchMedia("(prefers-color-scheme: dark)").matches
          );
        });
        const [showAddRecipeModal, setShowAddRecipeModal] = useState(false);
        const [showRecipeDetails, setShowRecipeDetails] = useState(null); // Holds the recipe object to show details for
        const [showMealPlanModal, setShowMealPlanModal] = useState(false);
        const [showShoppingListModal, setShowShoppingListModal] =
          useState(false);
        const [editingRecipe, setEditingRecipe] = useState(null); // Holds recipe object being edited
        const [toasts, setToasts] = useState([]); // Array of active toast notifications

        // --- Effects ---
        // Apply theme class to HTML element based on system preference
        useEffect(() => {
          const root = window.document.documentElement; // Get the <html> element
          if (isDarkMode) {
            root.classList.add("dark");
          } else {
            root.classList.remove("dark");
          }

          // Listener for system theme changes
          const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
          const handleChange = (e) => setIsDarkMode(e.matches);
          mediaQuery.addEventListener("change", handleChange);

          return () => mediaQuery.removeEventListener("change", handleChange);
        }, [isDarkMode]); // Re-run when isDarkMode changes

        // Initialize meal plan structure if it's empty or invalid
        const initializeMealPlan = useCallback(() => {
          const days = [
            "Sunday",
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday",
          ];
          const mealTimes = [
            "breakfast",
            "morningSnack",
            "lunch",
            "afternoonSnack",
            "dinner",
          ];

          setMealPlan((prev) => {
            // Check if the existing plan has the basic structure
            if (
              prev &&
              typeof prev === "object" &&
              Object.keys(prev).length > 0
            ) {
              let structureValid = days.every(
                (day) => prev[day] && typeof prev[day] === "object"
              );
              // Further check if all meal times exist for each day
              if (structureValid) {
                structureValid = days.every((day) =>
                  mealTimes.every((mealTime) => mealTime in prev[day])
                );
              }
              // If structure is valid, keep the existing plan
              if (structureValid) return prev;
            }

            // If structure is invalid or plan is empty, create a new empty structure
            console.log("Initializing empty meal plan structure.");
            const newPlan = {};
            days.forEach((day) => {
              newPlan[day] = {};
              mealTimes.forEach((mealTime) => {
                newPlan[day][mealTime] = null; // Initialize each slot as null
              });
            });
            return newPlan;
          });
        }, [setMealPlan]); // setMealPlan is stable, but included for clarity        // Run meal plan initialization on mount
        useEffect(() => {
          initializeMealPlan();
        }, [initializeMealPlan]);

        // Handle recipe export (global)
        useEffect(() => {
          const handleExport = () => {
            const dataStr = JSON.stringify(recipes, null, 2);
            const blob = new Blob([dataStr], {
              type: "application/json",
            });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "my-recipes.json";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            addToast("Recipes exported successfully!", "success");
          };

          document.addEventListener("exportRecipes", handleExport);
          return () =>
            document.removeEventListener("exportRecipes", handleExport);
        }, [recipes, addToast]);

        // Add/remove class to body to prevent scrolling when a modal is open
        useEffect(() => {
          const body = document.body;
          const isModalOpen =
            showAddRecipeModal ||
            !!showRecipeDetails || // Check if showRecipeDetails is truthy (not null)
            showMealPlanModal ||
            showShoppingListModal;

          if (isModalOpen) {
            body.classList.add("modal-open");
          } else {
            body.classList.remove("modal-open");
          }
          // Cleanup function to remove class if component unmounts while modal is open
          return () => body.classList.remove("modal-open");
        }, [
          showAddRecipeModal,
          showRecipeDetails,
          showMealPlanModal,
          showShoppingListModal,
        ]); // Re-run when any modal's visibility changes

        // --- Callbacks ---
        // Export recipes (global)
        const exportRecipes = useCallback(() => {
          try {
            if (!Array.isArray(recipes)) {
              throw new Error("No recipes found to export");
            }

            const dataStr = JSON.stringify(recipes || [], null, 2);
            const blob = new Blob([dataStr], {
              type: "application/json",
            });

            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "my-recipes.json";

            // Safety check before appending
            if (document.body) {
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
            } else {
              throw new Error("Document body not available");
            }

            // Cleanup
            URL.revokeObjectURL(url);

            // Success feedback
            addToast?.("Recipes exported successfully!", "success");
          } catch (err) {
            console.error("Export error:", err);
            addToast?.("Error exporting recipes.", "error");
          }
          addToast("Recipes exported successfully!", "success");
        }, [recipes, addToast]);

        // Clear all recipes and related data
        const deleteAllRecipes = useCallback(() => {
          if (
            !window.confirm(
              "Are you sure you want to delete ALL recipes, meal plans, and shopping list? This cannot be undone!"
            )
          ) {
            return;
          }
          setRecipes([]);
          setMealPlan({});
          setShoppingList([]);
          addToast(
            "All recipes and related data have been deleted.",
            "success"
          );
        }, [setRecipes, setMealPlan, setShoppingList, addToast]);

        // Remove a toast notification by its ID
        const removeToast = useCallback((id) => {
          setToasts((prevToasts) =>
            prevToasts.filter((toast) => toast.id !== id)
          );
        }, []); // No dependencies needed

        // Add a new toast notification
        const addToast = useCallback(
          (message, type = "info") => {
            const newToast = { id: Date.now(), message, type };
            setToasts((prevToasts) => [...prevToasts, newToast]);
            // Automatically remove the toast after 3 seconds (matches CSS animation)
            // Note: The Toast component also has a timer, this ensures removal from state
            setTimeout(() => removeToast(newToast.id), 3000);
          },
          [removeToast] // Dependency: removeToast function
        );

        // Add a new recipe
        const addRecipe = useCallback(
          (recipeData) => {
            const newRecipe = {
              id:
                Date.now().toString(36) +
                Math.random().toString(36).substr(2, 5), // Generate unique ID
              ...recipeData,
              description: recipeData.description || "", // Ensure description exists
              tags: recipeData.tags || [], // Ensure tags is an array
              dietaryTypes: recipeData.dietaryTypes || [],
              ingredients: recipeData.ingredients || [],
              directions: recipeData.directions || [],
              tipsAndTricks: recipeData.tipsAndTricks || [], // Ensure tipsAndTricks exists
              yield: recipeData.yield || "", // Ensure yield exists
              createdAt: new Date().toISOString(),
              isFavorite: false, // New recipes are not favorite by default
            };
            setRecipes((prev) => [...prev, newRecipe]);
            setShowAddRecipeModal(false); // Close modal
            setEditingRecipe(null); // Clear editing state
            addToast("Recipe added!", "success");
          },
          [setRecipes, addToast] // Dependencies: setRecipes, addToast
        );

        // Update an existing recipe
        const updateRecipe = useCallback(
          (id, recipeData) => {
            setRecipes((prev) =>
              prev.map((r) =>
                r.id === id
                  ? {
                      ...r, // Keep existing fields like id, createdAt, isFavorite
                      ...recipeData, // Overwrite with new data
                      description: recipeData.description || "", // Ensure description exists
                      tags: recipeData.tags || [], // Ensure tags is an array
                      dietaryTypes: recipeData.dietaryTypes || [],
                      ingredients: recipeData.ingredients || [],
                      directions: recipeData.directions || [],
                      tipsAndTricks: recipeData.tipsAndTricks || [], // Ensure tipsAndTricks exists
                      yield: recipeData.yield || "", // Ensure yield exists
                      updatedAt: new Date().toISOString(), // Add/update timestamp
                    }
                  : r
              )
            );
            setShowAddRecipeModal(false); // Close modal
            setEditingRecipe(null); // Clear editing state
            addToast("Recipe updated!", "success");
          },
          [setRecipes, addToast] // Dependencies: setRecipes, addToast
        );

        // Delete a recipe
        const deleteRecipe = useCallback(
          (id) => {
            // Confirmation dialog
            if (
              !window.confirm(
                "Are you sure you want to delete this recipe permanently?"
              )
            )
              return;

            // Remove from recipes list
            setRecipes((prev) => prev.filter((r) => r.id !== id));

            // Remove from meal plan
            setMealPlan((prev) => {
              const newPlan = JSON.parse(JSON.stringify(prev)); // Deep copy to avoid mutation
              let changed = false;
              Object.keys(newPlan).forEach((day) => {
                if (newPlan[day] && typeof newPlan[day] === "object") {
                  Object.keys(newPlan[day]).forEach((mealTime) => {
                    if (newPlan[day][mealTime] === id) {
                      newPlan[day][mealTime] = null; // Set slot to null
                      changed = true;
                    }
                  });
                }
              });
              return changed ? newPlan : prev; // Return new plan only if modified
            });

            // Remove associated items from shopping list
            setShoppingList((prev) =>
              prev.filter((item) => item.recipeId !== id)
            );

            // Close details modal if the deleted recipe was open
            if (showRecipeDetails?.id === id) setShowRecipeDetails(null);

            addToast("Recipe deleted.", "success");
          },
          [
            setRecipes,
            setMealPlan,
            setShoppingList,
            addToast,
            showRecipeDetails,
          ] // Dependencies
        );

        // Toggle the favorite status of a recipe
        const toggleFavorite = useCallback(
          (id) => {
            let isNowFavorite = false;
            setRecipes((prev) =>
              prev.map((r) => {
                if (r.id === id) {
                  isNowFavorite = !r.isFavorite; // Determine the new status
                  return { ...r, isFavorite: isNowFavorite };
                }
                return r;
              })
            );
            // Show appropriate toast message
            addToast(
              isNowFavorite ? "Added to Favorites" : "Removed from Favorites",
              "success"
            );
          },
          [setRecipes, addToast] // Dependencies
        );

        // Search/filter recipes based on query and filter criteria
        const searchRecipes = useCallback(
          (query, filters) => {
            filters = filters || {}; // Ensure filters object exists
            const normalizedQuery = query ? query.toLowerCase().trim() : "";
            const normalizedTagQuery = filters.tag
              ? filters.tag.toLowerCase().trim()
              : ""; // For exact tag matching

            return recipes.filter((recipe) => {
              // Basic check for valid recipe object
              if (!recipe || typeof recipe.name !== "string") return false;

              // --- Query Matching ---
              let matchesQuery = !normalizedQuery; // True if query is empty
              if (normalizedQuery) {
                const nameMatch = recipe.name
                  .toLowerCase()
                  .includes(normalizedQuery);
                const descriptionMatch = recipe.description // Search description too
                  ?.toLowerCase()
                  .includes(normalizedQuery);
                const ingredientMatch = recipe.ingredients?.some(
                  (ing) =>
                    typeof ing === "string" &&
                    ing.toLowerCase().includes(normalizedQuery)
                );
                const typeMatch = recipe.type
                  ?.toLowerCase()
                  .includes(normalizedQuery);
                const dietaryMatch = recipe.dietaryTypes?.some(
                  (type) =>
                    typeof type === "string" &&
                    type.toLowerCase().includes(normalizedQuery)
                );
                const tagMatch = recipe.tags?.some(
                  (tag) =>
                    typeof tag === "string" &&
                    tag.toLowerCase().includes(normalizedQuery)
                );
                const tipsMatch = recipe.tipsAndTricks?.some(
                  (tip) =>
                    typeof tip === "string" &&
                    tip.toLowerCase().includes(normalizedQuery)
                );

                // Default: search across multiple fields including description
                matchesQuery =
                  nameMatch ||
                  descriptionMatch || // Added description match
                  ingredientMatch ||
                  typeMatch ||
                  dietaryMatch ||
                  tagMatch ||
                  tipsMatch;
              }

              // --- Filter Matching ---
              const matchesType = filters.type
                ? recipe.type === filters.type
                : true;
              const matchesDietary = filters.dietaryType
                ? recipe.dietaryTypes?.includes(filters.dietaryType)
                : true;
              // Tag filter requires exact match (case-insensitive)
              const matchesTag = normalizedTagQuery
                ? recipe.tags?.some(
                    (tag) => tag.toLowerCase() === normalizedTagQuery
                  )
                : true;
              const matchesFavorite = filters.favorites
                ? recipe.isFavorite === true
                : true;

              // Cook time filter (Total Time <= filter value)
              const totalTime =
                parseInt(recipe.prepTime || 0) +
                parseInt(recipe.cookTime || 0) +
                parseInt(recipe.additionalTime || 0);
              const filterCookTime = filters.cookTime
                ? parseInt(filters.cookTime)
                : Infinity;
              const matchesCookTime = filters.cookTime
                ? totalTime <= filterCookTime
                : true;

              // Recipe must match all active filters and the query
              return (
                matchesQuery &&
                matchesType &&
                matchesDietary &&
                matchesTag &&
                matchesFavorite &&
                matchesCookTime
              );
            });
          },
          [recipes] // Dependency: recipes list
        );

        // Update a specific meal slot in the meal plan
        const updateMealPlan = useCallback(
          (day, mealTime, recipeId) => {
            setMealPlan((prev) => ({
              ...prev, // Spread existing plan
              [day]: { ...(prev?.[day] || {}), [mealTime]: recipeId }, // Update specific day and mealTime
            }));
            addToast("Meal plan updated!", "success");
          },
          [setMealPlan, addToast] // Dependencies
        );

        // Remove a meal from a specific slot in the meal plan
        const removeMealFromPlan = useCallback(
          (day, mealTime) => {
            setMealPlan((prev) => {
              // Only update if the meal exists
              if (!prev?.[day]?.[mealTime]) return prev;
              // Create new object for the day with the meal removed (set to null)
              return { ...prev, [day]: { ...prev[day], [mealTime]: null } };
            });
            addToast("Meal removed from plan.", "success");
          },
          [setMealPlan, addToast] // Dependencies
        );

        // Add ingredients from multiple recipes to the shopping list
        const addMultipleRecipesToShoppingList = useCallback(
          (recipeIds) => {
            if (!Array.isArray(recipeIds) || recipeIds.length === 0) return;

            let totalIngredientsAdded = 0;
            const recipeNamesAdded = new Set(); // Track names for the toast message
            const allNewItems = []; // Collect all new items before updating state

            setShoppingList((prevList) => {
              const currentNormalizedItems = new Set(
                prevList.map((item) => item.normalizedText)
              );
              const newList = [...prevList]; // Start with current list

              recipeIds.forEach((recipeId) => {
                const recipe = recipes.find((r) => r.id === recipeId);
                // Skip if recipe not found or has no ingredients
                if (
                  !recipe ||
                  !Array.isArray(recipe.ingredients) ||
                  recipe.ingredients.length === 0
                ) {
                  console.warn(
                    `Recipe ${recipeId} not found or has no ingredients.`
                  );
                  return;
                }

                recipe.ingredients
                  .filter((ing) => typeof ing === "string" && ing.trim() !== "") // Ensure ingredient is a non-empty string
                  .forEach((ingredient) => {
                    const normalized = normalizeIngredient(ingredient);
                    // Only add if not already present (to avoid basic duplicates)
                    // Note: More sophisticated merging logic for quantities can be added here
                    if (!currentNormalizedItems.has(normalized)) {
                      newList.push({
                        id:
                          Date.now().toString(36) +
                          Math.random().toString(36).substr(2, 5), // Unique ID for list item
                        text: ingredient.trim(), // Store original text
                        recipeId: recipe.id,
                        recipeName: recipe.name,
                        checked: false, // Default to unchecked
                        normalizedText: normalized, // Store normalized text for grouping
                      });
                      currentNormalizedItems.add(normalized); // Add to seen set
                      totalIngredientsAdded++;
                    }
                  });
                recipeNamesAdded.add(recipe.name);
              });

              if (totalIngredientsAdded > 0) {
                addToast(
                  `Added ${totalIngredientsAdded} ingredient(s) from ${recipeNamesAdded.size} recipe(s).`,
                  "success"
                );
              } else {
                addToast("No new ingredients to add.", "info");
              }
              return newList;
            });
          },
          [recipes, setShoppingList, addToast] // Dependencies
        );

        // Convenience function to add a single recipe's ingredients to the list
        const addToShoppingList = useCallback(
          (recipeId) => {
            addMultipleRecipesToShoppingList([recipeId]);
          },
          [addMultipleRecipesToShoppingList] // Dependency
        );

        // Toggle the checked state of shopping list items
        // Can toggle a single item by ID, or all items with the same normalized text
        const toggleShoppingItem = useCallback(
          (itemId, normalizedTextToToggle) => {
            setShoppingList((prevList) => {
              let targetChecked; // The state to set matching items to (true or false)
              let targetNormalizedText; // The normalized text to match against

              if (itemId) {
                // Toggle based on a specific item ID
                const clickedItem = prevList.find((item) => item.id === itemId);
                if (!clickedItem) return prevList; // Item not found, do nothing
                targetChecked = !clickedItem.checked; // Flip the clicked item's state
                targetNormalizedText = clickedItem.normalizedText; // Target items with the same normalized text
              } else if (normalizedTextToToggle) {
                // Toggle based on normalized text (for common ingredients)
                const groupItems = prevList.filter(
                  (item) => item.normalizedText === normalizedTextToToggle
                );
                if (groupItems.length === 0) return prevList; // No matching items
                // If all items in the group are currently checked, uncheck all. Otherwise, check all.
                const allCurrentlyChecked = groupItems.every(
                  (item) => item.checked
                );
                targetChecked = !allCurrentlyChecked;
                targetNormalizedText = normalizedTextToToggle;
              } else {
                return prevList; // No valid identifier provided
              }

              // Map over the list and update items matching the target normalized text
              return prevList.map((item) => {
                if (item.normalizedText === targetNormalizedText) {
                  return { ...item, checked: targetChecked };
                }
                return item;
              });
            });
          },
          [setShoppingList] // Dependency
        );

        // Clear the entire shopping list after confirmation
        const clearShoppingList = useCallback(
          () => {
            if (
              window.confirm(
                "Are you sure you want to clear the entire shopping list?"
              )
            ) {
              setShoppingList([]);
              addToast("Shopping list cleared!", "success");
            }
          },
          [setShoppingList, addToast] // Dependency
        );

        // Generate a PDF document for a given recipe
        const generateRecipePDF = useCallback(
          async (recipe) => {
            // Basic validation
            if (!recipe || typeof recipe !== "object") {
              addToast("Invalid recipe data.", "error");
              return;
            }
            // Check if html2pdf library is loaded
            if (typeof html2pdf === "undefined") {
              addToast("PDF library not loaded. Please refresh.", "error");
              console.error("html2pdf is not defined");
              return;
            }

            addToast("Generating PDF...", "info");

            // Create a temporary div to hold the PDF content HTML
            const content = document.createElement("div");
            // Basic styling for the PDF content
            content.style.cssText = `font-family: sans-serif; padding: 30px; line-height: 1.6; color: #333; font-size: 10pt; max-width: 8.5in;`;

            // --- Build HTML content string ---
            const recipeName = escapeHTML(recipe.name || "Untitled");
            const recipeDescriptionHtml = recipe.description
              ? `<p style="font-size: 10pt; color: #555; margin-bottom: 20px; text-align: center; font-style: italic;">${escapeHTML(
                  recipe.description
                )}</p>`
              : "";
            const dietaryTypesHtml =
              Array.isArray(recipe.dietaryTypes) &&
              recipe.dietaryTypes.length > 0
                ? `<p style="font-size: 9pt; color: #777;">Dietary: ${recipe.dietaryTypes
                    .map(escapeHTML)
                    .join(", ")}</p>`
                : "";
            const tagsHtml =
              Array.isArray(recipe.tags) && recipe.tags.length > 0
                ? `<p style="font-size: 9pt; color: #777;">Tags: ${recipe.tags
                    .map(escapeHTML)
                    .join(", ")}</p>`
                : "";

            // Image placeholder or actual image
            let imageHtml = `<div style="text-align: center; margin-bottom: 25px; padding: 20px; border: 1px dashed #ccc; color: #888; border-radius: 8px;">No Image</div>`;
            if (recipe.image) {
              // Use the Data URL directly if available
              imageHtml = `<img src="${recipe.image}" style="max-width: 250px; max-height: 250px; display: block; margin: 0 auto 25px; border-radius: 8px; border: 1px solid #eee;" alt="${recipeName}"/>`;
            }

            // Time fields
            const prepTimeFormatted = formatMinutesToHoursMinutes(
              recipe.prepTime
            );
            const cookTimeFormatted = formatMinutesToHoursMinutes(
              recipe.cookTime
            );
            const additionalTimeFormatted = formatMinutesToHoursMinutes(
              recipe.additionalTime
            );
            const totalTimeFormatted = formatMinutesToHoursMinutes(
              (recipe.prepTime || 0) +
                (recipe.cookTime || 0) +
                (recipe.additionalTime || 0)
            );

            // Yield information for PDF (static, not scaled)
            const yieldHtml = recipe.yield
              ? `<p style="margin: 6px 0;">Yield: ${escapeHTML(
                  recipe.yield
                )}</p>`
              : "";

            // Ingredients list HTML
            const ingredientsHtml =
              Array.isArray(recipe.ingredients) && recipe.ingredients.length > 0
                ? recipe.ingredients
                    .map(
                      (ing) =>
                        `<li style="margin-bottom: 5px;">${escapeHTML(
                          ing || ""
                        )}</li>`
                    )
                    .join("")
                : "<li>No ingredients listed.</li>";

            // Directions list HTML
            const directionsHtml =
              Array.isArray(recipe.directions) && recipe.directions.length > 0
                ? recipe.directions
                    .map(
                      (dir, i) =>
                        `<li style="margin-bottom: 12px; padding-left: 5px; border-left: 2px solid #2ecc71;"><strong>Step ${
                          i + 1
                        }:</strong> ${escapeHTML(dir || "")}</li>`
                    )
                    .join("")
                : "<li>No directions listed.</li>";

            // Tips and Tricks list HTML
            const tipsAndTricksHtml =
              Array.isArray(recipe.tipsAndTricks) &&
              recipe.tipsAndTricks.length > 0
                ? recipe.tipsAndTricks
                    .map(
                      (tip) =>
                        `<li style="margin-bottom: 8px; padding-left: 5px; border-left: 2px solid #f59e0b;"><strong>Tip:</strong> ${escapeHTML(
                          tip || ""
                        )}</li>`
                    )
                    .join("")
                : "<li>No tips and tricks listed.</li>";

            // Assemble the full HTML structure
            content.innerHTML = `
              <div style="text-align: center; margin-bottom: 10px;">
                <h1 style="color: #2ecc71; margin: 0 0 8px 0; font-size: 20pt; font-weight: bold;">${recipeName}</h1>
                <p style="margin: 0; font-size: 11pt; color: #555;">Type: ${escapeHTML(
                  recipe.type || "N/A"
                )} | Servings: ${recipe.servings || "N/A"}</p>
                ${dietaryTypesHtml}
                ${tagsHtml}
              </div>
              ${recipeDescriptionHtml}
              ${imageHtml}
              <div style="display: flex; flex-wrap: wrap; justify-content: space-between; gap: 20px; margin-bottom: 30px; border-top: 1px solid #eee; border-bottom: 1px solid #eee; padding: 20px 0;">
                <div style="flex: 1; min-width: 150px;">
                  <h3 style="color: #2ecc71; margin: 0 0 12px 0; font-size: 13pt; border-bottom: 1px solid #eee; padding-bottom: 6px;">Details</h3>
                  ${
                    prepTimeFormatted
                      ? `<p style="margin: 6px 0;">Prep: ${prepTimeFormatted}</p>`
                      : ""
                  }
                  ${
                    cookTimeFormatted
                      ? `<p style="margin: 6px 0;">Cook: ${cookTimeFormatted}</p>`
                      : ""
                  }
                  ${
                    additionalTimeFormatted
                      ? `<p style="margin: 6px 0;">Additional: ${additionalTimeFormatted}</p>`
                      : ""
                  }
                  <p style="margin: 10px 0 0 0; font-weight: bold;">Total: ${totalTimeFormatted}</p>
                  ${yieldHtml}
                </div>
                <div style="flex: 1; min-width: 150px;">
                  <h3 style="color: #2ecc71; margin: 0 0 12px 0; font-size: 13pt; border-bottom: 1px solid #eee; padding-bottom: 6px;">Nutrition (per serving)</h3>
                  <p style="margin: 6px 0;">Calories: ${
                    recipe.calories || "N/A"
                  }</p>
                  <p style="margin: 6px 0;">Protein: ${
                    recipe.protein ? recipe.protein + "g" : "N/A"
                  }</p>
                  <p style="margin: 6px 0;">Carbs: ${
                    recipe.carbs ? recipe.carbs + "g" : "N/A"
                  }</p>
                  <p style="margin: 6px 0;">Fat: ${
                    recipe.fat ? recipe.fat + "g" : "N/A"
                  }</p>
                </div>
              </div>
              <div style="margin-bottom: 30px;">
                <h3 style="color: #2ecc71; margin: 0 0 12px 0; font-size: 13pt; border-bottom: 1px solid #eee; padding-bottom: 6px;">Ingredients</h3>
                <ul style="list-style: disc; padding-left: 25px; margin: 0;">${ingredientsHtml}</ul>
              </div>
              <div style="margin-bottom: 30px;">
                <h3 style="color: #2ecc71; margin: 0 0 12px 0; font-size: 13pt; border-bottom: 1px solid #eee; padding-bottom: 6px;">Directions</h3>
                <ol style="list-style: none; padding-left: 0; margin: 0;">${directionsHtml}</ol>
              </div>
              <div>
                <h3 style="color: #f59e0b; margin: 0 0 12px 0; font-size: 13pt; border-bottom: 1px solid #eee; padding-bottom: 6px;">Tips & Tricks</h3>
                <ul style="list-style: none; padding-left: 0; margin: 0;">${tipsAndTricksHtml}</ul>
              </div>
            `;

            // --- PDF Generation Options ---
            const opt = {
              margin: 0.5, // Margins in inches
              filename: `${recipeName
                .toLowerCase()
                .replace(/[^a-z0-9]+/g, "-")}-recipe.pdf`, // Sanitize filename
              image: { type: "jpeg", quality: 0.95 }, // Image settings
              html2canvas: {
                scale: 2, // Higher scale for better resolution
                useCORS: true, // Important if using external images (though we use Data URLs here)
                logging: false, // Disable console logging from html2canvas
                allowTaint: true, // May help with cross-origin images if useCORS fails
              },
              jsPDF: { unit: "in", format: "letter", orientation: "portrait" }, // PDF document settings
              pagebreak: { mode: ["avoid-all", "css", "legacy"] }, // Page break handling modes
            };

            // --- Generate and Save PDF ---
            try {
              const worker = html2pdf().set(opt).from(content); // Create worker
              await worker.save(); // Trigger download
              addToast("PDF downloaded!", "success");
            } catch (error) {
              console.error("PDF Generation Error:", error);
              addToast(
                `PDF generation failed: ${error.message || "Unknown error"}`,
                "error"
              );
              if (error.stack) {
                console.error(error.stack); // Log stack trace for debugging
              }
            }
          },
          [addToast] // Dependency
        );

        // --- Render ---
        return (
          <div className="min-h-screen flex flex-col">
            {/* Header Component */}
            <Header
              openAddRecipeModal={() => {
                setEditingRecipe(null); // Ensure not editing when opening add modal
                setShowAddRecipeModal(true);
              }}
              openMealPlanModal={() => setShowMealPlanModal(true)}
              openShoppingListModal={() => setShowShoppingListModal(true)}
              recipes={recipes}
              addToast={addToast}
              setRecipes={setRecipes}
              deleteAllRecipes={deleteAllRecipes}
            />
            {/* Main Content Area */}
            <main className="flex-grow max-w-7xl mx-auto p-3 sm:p-4 w-full">
              {/* Main Recipe List Section */}
              <RecipeList
                recipes={recipes}
                searchRecipes={searchRecipes} // Pass search function
                openRecipeDetails={(recipe) => setShowRecipeDetails(recipe)}
                toggleFavorite={toggleFavorite}
              />
            </main>
            {/* --- Modals (conditionally rendered) --- */}
            {showAddRecipeModal && (
              <AddRecipeModal
                onClose={() => {
                  setShowAddRecipeModal(false);
                  setEditingRecipe(null); // Clear editing state on close
                }}
                addRecipe={addRecipe}
                updateRecipe={updateRecipe}
                editingRecipe={editingRecipe} // Pass recipe if editing, null otherwise
                addToast={addToast}
              />
            )}
            {showRecipeDetails && (
              <RecipeDetailsModal
                recipe={showRecipeDetails} // Pass the selected recipe
                onClose={() => setShowRecipeDetails(null)}
                addToShoppingList={addToShoppingList}
                generateRecipePDF={generateRecipePDF}
                deleteRecipe={deleteRecipe}
                editRecipe={(recipe) => {
                  // Function to switch to edit mode
                  setEditingRecipe(recipe);
                  setShowRecipeDetails(null); // Close details modal
                  setShowAddRecipeModal(true); // Open add/edit modal
                }}
                toggleFavorite={toggleFavorite}
                addToast={addToast}
              />
            )}
            {showMealPlanModal && (
              <MealPlanModal
                mealPlan={mealPlan}
                recipes={recipes}
                updateMealPlan={updateMealPlan}
                removeMealFromPlan={removeMealFromPlan}
                addMultipleRecipesToShoppingList={
                  addMultipleRecipesToShoppingList
                }
                onClose={() => setShowMealPlanModal(false)}
              />
            )}
            {showShoppingListModal && (
              <ShoppingListModal
                shoppingList={shoppingList}
                toggleShoppingItem={toggleShoppingItem}
                clearShoppingList={clearShoppingList}
                addToast={addToast}
                onClose={() => setShowShoppingListModal(false)}
              />
            )}
            {/* Toast Container */}
            <div className="fixed bottom-4 right-4 z-[100] space-y-2">
              {toasts.map((toast) => (
                <Toast
                  key={toast.id}
                  message={toast.message}
                  type={toast.type}
                  onClose={() => removeToast(toast.id)} // Pass remove function
                />
              ))}
            </div>
            {/* Footer Component */}
            <Footer />
          </div>
        );
      };

      // --- Header Component ---
      const Header = ({
        openAddRecipeModal,
        openMealPlanModal,
        openShoppingListModal,
        recipes,
        addToast,
        setRecipes,
        deleteAllRecipes,
      }) => {
        // State for search input
        const [searchQuery, setSearchQuery] = useState("");
        const debounceTimeoutRef = useRef(null); // Ref to store debounce timer

        // Debounced search handler
        const handleSearchChange = useCallback((e) => {
          const query = e.target.value;
          setSearchQuery(query);

          // Clear existing debounce timer
          if (debounceTimeoutRef.current)
            clearTimeout(debounceTimeoutRef.current);

          // Set new timer to dispatch search event after 350ms
          debounceTimeoutRef.current = setTimeout(() => {
            document.dispatchEvent(
              new CustomEvent("searchRecipes", {
                detail: { query, type: "search" }, // Indicate it's a search query
              })
            );
          }, 350);
        }, []);

        // Toggle visibility of all recipes and clear filters/search
        const handleToggleAllRecipes = useCallback(() => {
          // Dispatch event to toggle visibility and clear filters/search
          document.dispatchEvent(
            new CustomEvent("searchRecipes", {
              detail: { type: "toggleAll" },
            })
          );
          setSearchQuery(""); // Clear search query in Header
        }, []);

        // Cleanup debounce timer on unmount
        useEffect(
          () => () => {
            if (debounceTimeoutRef.current)
              clearTimeout(debounceTimeoutRef.current);
          },
          []
        );

        return (
          <header className="bg-white dark:bg-gray-800 shadow-md p-3 sticky top-0 z-30 transition-colors duration-300">
            <nav className="max-w-7xl mx-auto flex justify-between items-center flex-wrap gap-y-2 gap-x-3">
              {/* Logo/Title */}
              <h1 className="text-lg sm:text-xl font-bold text-green-500 whitespace-nowrap flex items-center gap-2 order-1 sm:order-1">
                <i className="fas fa-book-open text-green-500"></i>
                <span className="hidden sm:inline">Recipe Manager Pro</span>
                <span className="sm:hidden">Recipes</span>{" "}
                {/* Shorter title for small screens */}
              </h1>

              {/* Search Bar */}
              <div className="flex-grow flex items-center bg-gray-100 dark:bg-gray-700 rounded-full px-3 py-1.5 w-full sm:w-auto sm:flex-grow sm:max-w-md md:mx-auto order-3 sm:order-2">
                <i className="fas fa-search text-gray-400 dark:text-gray-500 mr-2 text-sm"></i>
                <input
                  type="search"
                  placeholder="Search recipes..."
                  value={searchQuery}
                  className="bg-transparent outline-none text-sm text-gray-900 dark:text-gray-100 placeholder-gray-500 dark:placeholder-gray-400 w-full"
                  onChange={handleSearchChange}
                  aria-label="Search recipes"
                />
              </div>

              {/* Action Buttons */}
              <div className="flex items-center gap-1.5 sm:gap-2 order-2 sm:order-3">
                {/* All Recipes Toggle Button */}
                <button
                  onClick={handleToggleAllRecipes}
                  className="btn-header"
                  title="Show/Hide All Recipes"
                >
                  <i className="fas fa-list-alt text-green-500"></i>
                  <span className="hidden lg:inline ml-1">All</span>
                </button>
                {/* Meal Plan Button */}
                <button
                  onClick={openMealPlanModal}
                  className="btn-header"
                  title="Meal Plan"
                >
                  <i className="fas fa-calendar-alt text-green-500"></i>
                  <span className="hidden lg:inline ml-1">Plan</span>{" "}
                  {/* Show text on larger screens */}
                </button>
                {/* Shopping List Button */}
                <button
                  onClick={openShoppingListModal}
                  className="btn-header"
                  title="Shopping List"
                >
                  <i className="fas fa-shopping-cart text-green-500"></i>
                  <span className="hidden lg:inline ml-1">List</span>
                </button>
                {/* Add Recipe Button */}
                <button
                  onClick={openAddRecipeModal}
                  className="btn-header bg-green-500 text-white hover:bg-green-600 dark:hover:bg-green-600"
                  title="Add Recipe"
                >
                  <i className="fas fa-plus text-green-500"></i>
                  <span className="hidden lg:inline ml-1">Add</span>
                </button>
                {/* Delete All Recipes Button */}
                <button
                  onClick={deleteAllRecipes}
                  className="btn-header bg-red-500 text-white hover:bg-red-600 dark:hover:bg-red-600"
                  title="Delete All Recipes"
                >
                  <i className="fas fa-trash-alt text-green-500"></i>
                  <span className="hidden lg:inline ml-1">Delete All</span>
                </button>
                {/* Import/Export Buttons */}
                <button
                  onClick={() => {
                    try {
                      const dataStr = JSON.stringify(recipes || [], null, 2);
                      const blob = new Blob([dataStr], {
                        type: "application/json",
                      });
                      const url = URL.createObjectURL(blob);
                      const a = document.createElement("a");
                      a.href = url;
                      a.download = "my-recipes.json";
                      document.body.appendChild(a);
                      a.click();
                      document.body.removeChild(a);
                      URL.revokeObjectURL(url);
                      addToast?.("Recipes exported successfully!", "success");
                    } catch (err) {
                      console.error("Export error:", err);
                      addToast?.("Error exporting recipes.", "error");
                    }
                  }}
                  className="btn-header"
                  title="Export Recipes"
                >
                  <i className="fas fa-file-export text-green-500"></i>
                  <span className="hidden lg:inline ml-1">Export</span>
                </button>
                <button
                  onClick={() => {
                    const input = document.createElement("input");
                    input.type = "file";
                    input.accept = ".json";
                    input.onchange = async (e) => {
                      const file = e.target.files[0];
                      if (!file) return;

                      const reader = new FileReader();
                      reader.onload = async (e) => {
                        try {
                          const rawData = JSON.parse(e.target.result);
                          let importedRecipes = [];

                          // Check if it's a single recipe object or an array of recipes
                          if (Array.isArray(rawData)) {
                            importedRecipes = rawData;
                          } else if (
                            typeof rawData === "object" &&
                            rawData !== null &&
                            rawData.name
                          ) {
                            // Assume it's a single recipe object if it has a 'name' property
                            importedRecipes = [rawData];
                          } else {
                            throw new Error(
                              "Invalid file format: Expected a recipe object or an array of recipes."
                            );
                          }

                          // Generate unique IDs and validate recipe structure for all imported recipes
                          const timestamp = Date.now();
                          const processedRecipes = importedRecipes
                            .filter((recipe) => {
                              // Basic validation of required fields
                              const isValid =
                                recipe &&
                                typeof recipe === "object" &&
                                typeof recipe.name === "string" &&
                                recipe.name.trim() !== "";

                              if (!isValid) {
                                console.warn(
                                  "Skipping invalid recipe:",
                                  recipe
                                );
                              }
                              return isValid;
                            })
                            .map((recipe, index) => {
                              // Generate truly unique ID using timestamp, index and random suffix
                              const uniqueId = `${timestamp.toString(
                                36
                              )}-${index}-${Math.random()
                                .toString(36)
                                .substr(2, 5)}`;

                              // Validate and normalize all fields with defensive programming
                              return {
                                id: uniqueId,
                                name: recipe.name?.trim() || "Untitled Recipe",
                                description: recipe.description?.trim() || "",
                                type: recipe.type?.trim() || "Other",
                                // Ensure arrays are valid and elements are trimmed
                                dietaryTypes: Array.isArray(recipe.dietaryTypes)
                                  ? recipe.dietaryTypes
                                      .filter(
                                        (t) => typeof t === "string" && t.trim()
                                      )
                                      .map((t) => t.trim())
                                  : [],
                                tags: Array.isArray(recipe.tags)
                                  ? recipe.tags
                                      .filter(
                                        (t) => typeof t === "string" && t.trim()
                                      )
                                      .map((t) => t.trim())
                                  : [],
                                // Convert string times to numbers, with validation
                                prepTime: recipe.prepTime
                                  ? Math.max(0, parseInt(recipe.prepTime))
                                  : 0,
                                cookTime: recipe.cookTime
                                  ? Math.max(0, parseInt(recipe.cookTime))
                                  : 0,
                                additionalTime: recipe.additionalTime
                                  ? Math.max(0, parseInt(recipe.additionalTime))
                                  : 0,
                                servings: recipe.servings
                                  ? Math.max(1, parseInt(recipe.servings))
                                  : 1,
                                yield: recipe.yield?.trim() || "", // New: import yield
                                // Clean ingredients and directions
                                ingredients: Array.isArray(recipe.ingredients)
                                  ? recipe.ingredients
                                      .filter(
                                        (i) => typeof i === "string" && i.trim()
                                      )
                                      .map((i) => i.trim())
                                  : [],
                                directions: Array.isArray(recipe.directions)
                                  ? recipe.directions
                                      .filter(
                                        (d) => typeof d === "string" && d.trim()
                                      )
                                      .map((d) => d.trim())
                                  : [],
                                // Tips & Tricks, ensure it's an array of strings
                                tipsAndTricks: Array.isArray(
                                  recipe.tipsAndTricks
                                )
                                  ? recipe.tipsAndTricks
                                      .filter(
                                        (tip) =>
                                          typeof tip === "string" && tip.trim()
                                      )
                                      .map((tip) => tip.trim())
                                  : [],
                                // Handle optional numeric fields
                                calories: recipe.calories
                                  ? Math.max(0, parseInt(recipe.calories))
                                  : null,
                                protein: recipe.protein
                                  ? Math.max(0, parseFloat(recipe.protein))
                                  : null,
                                carbs: recipe.carbs
                                  ? Math.max(0, parseFloat(recipe.carbs))
                                  : null,
                                fat: recipe.fat
                                  ? Math.max(0, parseFloat(recipe.fat))
                                  : null,
                                // Handle media fields safely
                                image:
                                  typeof recipe.image === "string"
                                    ? recipe.image
                                    : null,
                                video:
                                  typeof recipe.video === "string"
                                    ? recipe.video
                                    : null,
                                // Set metadata
                                createdAt: new Date().toISOString(),
                                isFavorite: false,
                              };
                            });

                          if (processedRecipes.length === 0) {
                            addToast(
                              "No valid recipes found in import file.",
                              "error"
                            );
                            return;
                          }

                          // Update state and localStorage atomically in a single transaction
                          setRecipes((prevRecipes) => {
                            const updatedRecipes = [
                              ...prevRecipes,
                              ...processedRecipes,
                            ];
                            // Immediately persist to localStorage
                            try {
                              localStorage.setItem(
                                STORAGE_KEYS.RECIPES,
                                JSON.stringify(updatedRecipes)
                              );
                            } catch (storageError) {
                              console.error(
                                "Failed to save to localStorage:",
                                storageError
                              );
                              throw new Error(
                                "Failed to persist recipes to storage. Available space may be full."
                              );
                            }
                            return updatedRecipes;
                          });

                          addToast(
                            `Successfully imported ${processedRecipes.length} recipes!`,
                            "success"
                          );
                        } catch (err) {
                          console.error("Import error:", err);
                          addToast(
                            `Error importing recipes: ${
                              err.message || "Invalid file format"
                            }`,
                            "error"
                          );
                        }
                      };

                      reader.onerror = () => {
                        addToast(
                          "Error reading file. Please try again.",
                          "error"
                        );
                      };

                      reader.readAsText(file);
                    };
                    input.click();
                  }}
                  className="btn-header"
                  title="Import Recipes"
                >
                  <i className="fas fa-file-import text-green-500"></i>
                  <span className="hidden lg:inline ml-1">Import</span>
                </button>
                {/* Removed Theme Toggle Button */}
              </div>
            </nav>
          </header>
        );
      };

      // --- Recipe Suggestions Component ---
      // Shows a few suggested recipes (e.g., favorites or random)
      const RecipeSuggestions = ({
        recipes,
        openRecipeDetails,
        toggleFavorite,
      }) => {
        const [isExpanded, setIsExpanded] = useState(false); // State for collapsible section

        // Memoize suggested recipes to avoid recalculation on every render
        const suggested = useMemo(() => {
          if (!Array.isArray(recipes) || recipes.length === 0) return [];

          // Prioritize favorites, then add random non-favorites
          const favorites = recipes.filter((r) => r?.isFavorite === true);
          const nonFavorites = recipes.filter((r) => r?.isFavorite !== true);

          // Shuffle both lists to get variety
          favorites.sort(() => 0.5 - Math.random());
          nonFavorites.sort(() => 0.5 - Math.random());

          // Combine, prioritizing favorites, up to 3 suggestions
          const suggestions = [...favorites.slice(0, 2), ...nonFavorites];

          // Ensure uniqueness and limit to 3
          const uniqueSuggestions = [];
          const seenIds = new Set();
          for (const recipe of suggestions) {
            if (recipe?.id && !seenIds.has(recipe.id)) {
              uniqueSuggestions.push(recipe);
              seenIds.add(recipe.id);
              if (uniqueSuggestions.length === 3) break;
            }
          }
          return uniqueSuggestions;
        }, [recipes]); // Recalculate only if recipes change

        // Don't render if no suggestions
        if (!suggested || suggested.length === 0) return null;

        return (
          <section className="mb-6 sm:mb-8 p-3 sm:p-4 bg-gray-50 dark:bg-gray-800 rounded-lg shadow">
            {/* Collapsible Header Button */}
            <button
              onClick={() => setIsExpanded(!isExpanded)}
              className="flex justify-between items-center w-full text-left mb-3 sm:mb-4"
              aria-expanded={isExpanded}
              aria-controls="suggestions-content"
            >
              <h2 className="text-lg sm:text-xl font-semibold text-gray-800 dark:text-gray-200">
                Suggestions For You
              </h2>
              <i
                className={`fas fa-chevron-down text-gray-500 dark:text-gray-400 transform transition-transform duration-200 ${
                  isExpanded ? "rotate-180" : ""
                }`}
                aria-hidden="true"
              ></i>
            </button>

            {/* Collapsible Content */}
            <div
              id="suggestions-content"
              className={`collapsible-content ${isExpanded ? "expanded" : ""}`} // Apply animation classes
            >
              <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3 sm:gap-4">
                {suggested.map((recipe) => (
                  // Suggestion Card
                  <div
                    key={recipe.id}
                    className="bg-white dark:bg-gray-700 rounded-lg shadow overflow-hidden cursor-pointer hover:shadow-lg transition-shadow duration-300 flex flex-col"
                    onClick={() => openRecipeDetails(recipe)} // Open details on click
                    tabIndex="0" // Make it focusable
                    aria-label={`View suggestion: ${recipe.name}`}
                  >
                    {/* Image Area */}
                    <div className="aspect-video w-full bg-gray-200 dark:bg-gray-600 overflow-hidden relative">
                      {recipe.image ? (
                        <img
                          src={recipe.image}
                          alt={recipe.name}
                          className="w-full h-full object-cover"
                        />
                      ) : (
                        // Placeholder icon if no image
                        <div className="w-full h-full flex items-center justify-center text-gray-400 dark:text-gray-500">
                          <i className="fas fa-image text-3xl opacity-50"></i>
                        </div>
                      )}
                      {/* Favorite indicator */}
                      {recipe.isFavorite && (
                        <div className="absolute top-2 right-2 bg-black bg-opacity-40 text-yellow-400 p-1 rounded-full text-xs">
                          <i className="fas fa-star"></i>
                        </div>
                      )}
                    </div>
                    {/* Text Content Area */}
                    <div className="p-3 flex-grow flex flex-col">
                      <h3
                        className="text-base font-semibold mb-1 line-clamp-1 flex-grow" // Use line-clamp-1 for suggestion title
                        title={recipe.name}
                      >
                        {escapeHTML(recipe.name)}
                      </h3>
                      {/* Description Preview */}
                      {recipe.description && (
                        <p
                          className="text-xs text-gray-500 dark:text-gray-400 mb-1 line-clamp-2"
                          title={recipe.description}
                        >
                          {escapeHTML(recipe.description)}
                        </p>
                      )}
                      {/* Type and Favorite Button */}
                      <div className="flex justify-between items-center mt-auto pt-1">
                        <span className="inline-block bg-green-100 dark:bg-green-900 text-green-600 dark:text-green-300 text-xs px-2 py-0.5 rounded-full">
                          {escapeHTML(recipe.type)}
                        </span>
                        <button
                          onClick={(e) => {
                            e.stopPropagation(); // Prevent card click when clicking button
                            toggleFavorite(recipe.id);
                          }}
                          className={`text-xl ml-2 ${
                            recipe.isFavorite
                              ? "text-yellow-500"
                              : "text-gray-300 dark:text-gray-500"
                          } hover:text-yellow-400 dark:hover:text-yellow-400`}
                          title={
                            recipe.isFavorite
                              ? "Remove Favorite"
                              : "Add Favorite"
                          }
                          aria-label={
                            recipe.isFavorite
                              ? "Remove Favorite"
                              : "Add Favorite"
                          }
                        >
                          <i className={`fas fa-star`}></i>{" "}
                          {/* Always solid star, color indicates status */}
                        </button>
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          </section>
        );
      };
      // --- Recipe List Component ---
      // Displays the main list of recipes with filtering and sorting
      const RecipeList = ({
        recipes,
        searchRecipes,
        openRecipeDetails,
        toggleFavorite,
      }) => {
        // State for filtered recipes and filter settings
        const [filteredRecipes, setFilteredRecipes] = useState([]);
        const [filters, setFilters] = useState({
          query: "",
          type: "",
          dietaryType: "",
          tag: "",
          cookTime: "",
          favorites: false,
        });
        // New state to control if all recipes should be explicitly hidden
        const [hideAllExplicitly, setHideAllExplicitly] = useState(false);

        // Effect to update filteredRecipes when recipes, filters change
        useEffect(() => {
          // Determine if any filter is active (excluding the 'hideAllExplicitly' state itself)
          const isFilterActive =
            filters.query ||
            filters.type ||
            filters.dietaryType ||
            filters.tag ||
            filters.cookTime ||
            filters.favorites;

          let results = recipes;

          // If filters are active OR if hideAllExplicitly is FALSE (meaning we should show based on filters/all)
          if (isFilterActive || !hideAllExplicitly) {
            results = searchRecipes(filters.query, filters);
          }

          // Default sort: newest first
          const sorted = [...results].sort((a, b) => {
            if (!a.createdAt && !b.createdAt) return 0;
            if (!a.createdAt) return 1;
            if (!b.createdAt) return -1;
            return new Date(b.createdAt) - new Date(a.createdAt);
          });

          setFilteredRecipes(sorted);
        }, [recipes, filters, searchRecipes, hideAllExplicitly]);

        // Effect to listen for search events dispatched from the Header
        useEffect(() => {
          const handler = (e) => {
            if (e.detail.type === "toggleAll") {
              // Toggle the explicit hide state
              setHideAllExplicitly((prev) => !prev);
              // When toggling, also clear all filters and search query
              setFilters({
                query: "",
                type: "",
                dietaryType: "",
                tag: "",
                cookTime: "",
                favorites: false,
              });
            } else if (e.detail.type === "search") {
              // If it's a search event, ensure we are not explicitly hidden
              setHideAllExplicitly(false);
              setFilters((prev) => ({
                ...prev,
                query: e.detail.query,
              }));
            }
          };
          document.addEventListener("searchRecipes", handler);
          return () => document.removeEventListener("searchRecipes", handler);
        }, []);

        // Handler for filter dropdown/checkbox changes
        const handleFilterChange = useCallback((e) => {
          const { name, value, type, checked } = e.target;
          // When a filter is changed, ensure we're not in the "explicitly hidden" state
          setHideAllExplicitly(false);
          setFilters((prev) => ({
            ...prev,
            [name]: type === "checkbox" ? checked : value,
          }));
        }, []);

        // The list of recipes to display:
        // - If hideAllExplicitly is true, show an empty array.
        // - Otherwise, show filteredRecipes (which already accounts for search and filters).
        const recipesToDisplay = hideAllExplicitly ? [] : filteredRecipes;

        // Determine if any filters are active (excluding the 'hideAllExplicitly' state itself and query from this check, as query is handled separately for "no results")
        const hasActiveFiltersExcludingQuery =
          filters.type ||
          filters.dietaryType ||
          filters.tag ||
          filters.cookTime ||
          filters.favorites;

        return (
          <section>
            {/* Filter Controls */}
            <div className="mb-4 sm:mb-6 flex flex-wrap gap-5 items-center bg-gray-50 dark:bg-gray-800 p-2 sm:p-3 rounded-lg shadow-sm">
              <span className="text-sm font-medium mr-1 hidden md:inline text-gray-700 dark:text-gray-300">
                Filter:
              </span>
              {/* Filter Selects */}
              <select
                name="type"
                value={filters.type}
                onChange={handleFilterChange}
                className="filter-select text-xs sm:text-sm"
                aria-label="Filter Meal Type"
              >
                <option value="">All Types</option>
                {[...new Set(recipes.map((r) => r?.type).filter(Boolean))]
                  .sort()
                  .map((t) => (
                    <option key={t} value={t}>
                      {t}
                    </option>
                  ))}
              </select>
              <select
                name="dietaryType"
                value={filters.dietaryType}
                onChange={handleFilterChange}
                className="filter-select text-xs sm:text-sm"
                aria-label="Filter Dietary Type"
              >
                <option value="">All Dietary</option>
                {[
                  ...new Set(
                    recipes
                      .flatMap((r) => r?.dietaryTypes || [])
                      .filter(Boolean)
                  ),
                ]
                  .sort()
                  .map((t) => (
                    <option key={t} value={t}>
                      {t}
                    </option>
                  ))}
              </select>
              <select
                name="tag"
                value={filters.tag}
                onChange={handleFilterChange}
                className="filter-select text-xs sm:text-sm"
                aria-label="Filter by Tag"
              >
                <option value="">All Tags</option>
                {[
                  ...new Set(
                    recipes.flatMap((r) => r?.tags || []).filter(Boolean)
                  ),
                ]
                  .sort()
                  .map((t) => (
                    <option key={t} value={t}>
                      {t}
                    </option>
                  ))}
              </select>
              <select
                name="cookTime"
                value={filters.cookTime}
                onChange={handleFilterChange}
                className="filter-select text-xs sm:text-sm"
                aria-label="Filter Total Time"
              >
                <option value="">Any Time</option>
                {[15, 30, 45, 60, 90, 120].map((t) => (
                  <option key={t} value={t}>
                    ≤ {t} min
                  </option>
                ))}
              </select>
              {/* Favorites Filter Checkbox */}
              <label
                className="flex items-center gap-1 cursor-pointer text-xs sm:text-sm whitespace-nowrap ml-1 sm:ml-2 text-gray-700 dark:text-gray-300"
                title="Favorites Only"
              >
                <input
                  type="checkbox"
                  name="favorites"
                  checked={filters.favorites}
                  onChange={handleFilterChange}
                  className="w-3.5 h-3.5 sm:w-4 sm:h-4 rounded text-green-500 focus:ring-offset-0 focus:ring-green-500 border-gray-300 dark:border-gray-600"
                />
                <i className="fas fa-star text-yellow-400"></i>
                <span className="hidden sm:inline">Favs</span>
              </label>

              {/* Recipe Count */}
              <div className="ml-auto text-sm font-semibold text-gray-700 dark:text-gray-300 flex items-center gap-1">
                <i className="fas fa-utensils text-green-500"></i>
                Recipes: {recipesToDisplay.length}
              </div>
            </div>
            {/* Recipe Grid */}
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4 sm:gap-5">
              {recipesToDisplay.length > 0 ? (
                recipesToDisplay.map((recipe) => (
                  // Recipe Card
                  <div
                    key={recipe.id}
                    onClick={() => openRecipeDetails(recipe)}
                    tabIndex="0" // Make focusable
                    aria-label={`View recipe: ${recipe.name}`}
                    className="bg-white dark:bg-gray-800 rounded-lg shadow overflow-hidden cursor-pointer hover:shadow-xl focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 dark:focus:ring-offset-gray-900 transition-all duration-300 flex flex-col group" // Added group for hover effects
                  >
                    {/* Image Area */}
                    <div className="aspect-video w-full bg-gray-200 dark:bg-gray-700 overflow-hidden relative">
                      {recipe.image ? (
                        <img
                          src={recipe.image}
                          alt={recipe.name}
                          className="w-full h-full object-cover group-hover:scale-105 transition-transform duration-300"
                        /> // Zoom effect on hover
                      ) : (
                        <div className="w-full h-full flex items-center justify-center text-gray-400 dark:text-gray-500">
                          <i className="fas fa-image text-4xl mb-3 opacity-50"></i>
                        </div>
                      )}
                      {/* Favorite Button (absolute position) */}
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          toggleFavorite(recipe.id);
                        }}
                        aria-label={
                          recipe.isFavorite ? "Remove Favorite" : "Add Favorite"
                        }
                        className={`absolute top-2 right-2 text-2xl ${
                          recipe.isFavorite
                            ? "text-yellow-400 filter drop-shadow(0 1px 1px rgba(0,0,0,0.5))"
                            : "text-white text-opacity-50" // Style favorite differently
                        } hover:text-yellow-300 hover:text-opacity-100 transition-colors duration-200 z-10`}
                      >
                        <i
                          className={`fa-star ${
                            recipe.isFavorite ? "fas" : "far"
                          }`}
                        ></i>
                      </button>
                    </div>
                    {/* Text Content Area */}
                    <div className="p-3 sm:p-4 flex flex-col flex-grow">
                      <h3
                        className="text-base sm:text-lg font-semibold leading-tight mb-1 text-gray-900 dark:text-gray-100 line-clamp-2" // Limit title lines
                        title={recipe.name}
                      >
                        {escapeHTML(recipe.name)}
                      </h3>
                      {/* Description */}
                      {recipe.description && (
                        <p
                          className="text-xs sm:text-sm text-gray-600 dark:text-gray-400 mt-1 mb-2 line-clamp-2"
                          title={recipe.description}
                        >
                          {escapeHTML(recipe.description)}
                        </p>
                      )}
                      {/* Tags/Badges */}
                      <div className="flex flex-wrap gap-1 my-1 text-xs">
                        {/* Type Badge */}
                        <span className="inline-flex items-center gap-1 bg-green-100 dark:bg-green-900 text-green-600 dark:text-green-300 px-2 py-0.5 rounded-full">
                          <i className="fas fa-utensils opacity-70"></i>{" "}
                          {escapeHTML(recipe.type)}
                        </span>
                        {/* Dietary Badges */}
                        {recipe.dietaryTypes?.map((diet) => (
                          <span
                            key={diet}
                            className="inline-flex items-center gap-1 bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-300 px-2 py-0.5 rounded-full"
                          >
                            <i className="fas fa-leaf opacity-70"></i>{" "}
                            {escapeHTML(diet)}
                          </span>
                        ))}
                        {/* Tag Badges */}
                        {recipe.tags?.map((tag) => (
                          <span
                            key={tag}
                            className="inline-flex items-center gap-1 bg-purple-100 dark:bg-purple-900 text-purple-700 dark:text-purple-300 px-2 py-0.5 rounded-full"
                          >
                            <i className="fas fa-tag opacity-70"></i>{" "}
                            {escapeHTML(tag)}
                          </span>
                        ))}
                      </div>
                      {/* Time Info */}
                      <div className="mt-auto pt-2 text-xs text-gray-500 dark:text-gray-400 grid grid-cols-2 gap-x-2 gap-y-1">
                        {recipe.prepTime > 0 && (
                          <span title="Prep Time">
                            <i className="fas fa-clock w-3 tc mr-0.5 op-70"></i>{" "}
                            Prep: {formatMinutesToHoursMinutes(recipe.prepTime)}
                          </span>
                        )}
                        {recipe.cookTime > 0 && (
                          <span title="Cook Time">
                            <i className="fas fa-fire w-3 tc mr-0.5 op-70"></i>{" "}
                            Cook: {formatMinutesToHoursMinutes(recipe.cookTime)}
                          </span>
                        )}
                        {recipe.additionalTime > 0 && (
                          <span title="Additional Time">
                            <i className="fas fa-hourglass-half w-3 tc mr-0.5 op-70"></i>{" "}
                            Additional:{" "}
                            {formatMinutesToHoursMinutes(recipe.additionalTime)}
                          </span>
                        )}
                        {/* Total Time */}
                        <span
                          className="col-span-2 text-green-600 dark:text-green-400 font-medium text-sm mt-1 inline-flex items-center gap-1"
                          title="Total Time"
                        >
                          <i className="fas fa-stopwatch"></i> Total:{" "}
                          {formatMinutesToHoursMinutes(
                            parseInt(recipe.prepTime || 0) +
                              parseInt(recipe.cookTime || 0) +
                              parseInt(recipe.additionalTime || 0)
                          )}
                        </span>
                      </div>
                    </div>
                  </div>
                ))
              ) : (
                // Message when no recipes match filters or no recipes exist
                <div className="col-span-full text-center text-gray-500 dark:text-gray-400 py-10 px-4 bg-white dark:bg-gray-800 rounded-lg shadow">
                  <i className="fas fa-search text-4xl mb-3 opacity-50"></i>
                  <p className="font-semibold">
                    {hideAllExplicitly
                      ? "Recipes are currently hidden."
                      : filters.query
                      ? "No recipes found matching your search."
                      : hasActiveFiltersExcludingQuery
                      ? "No recipes found matching your filters."
                      : "No recipes added yet."}
                  </p>
                  <p className="text-sm">
                    {hideAllExplicitly
                      ? "Click 'All' to show them."
                      : filters.query || hasActiveFiltersExcludingQuery
                      ? "Try adjusting filters or search terms."
                      : "Click 'Add' to create your first recipe!"}
                  </p>
                </div>
              )}{" "}
            </div>
          </section>
        );
      };

      // --- Tag Input Component ---
      // Allows users to add and remove tags in a text input-like field
      const TagInput = ({ tags, setTags, maxTags = 10, addToast }) => {
        const [inputValue, setInputValue] = useState(""); // Current text in the input field

        // Handle key presses in the input
        const handleKeyDown = (e) => {
          // Add tag on Enter or Comma
          if (e.key === "Enter" || e.key === ",") {
            e.preventDefault(); // Prevent form submission or comma insertion
            const newTag = inputValue.trim();

            // Validate the new tag
            if (
              newTag &&
              tags.length < maxTags &&
              !tags.some((t) => t.toLowerCase() === newTag.toLowerCase())
            ) {
              // Add tag if valid, not a duplicate (case-insensitive), and under max limit
              setTags([...tags, newTag]);
            } else if (tags.length >= maxTags) {
              addToast(`Maximum ${maxTags} tags allowed.`, "error");
            } else if (
              newTag &&
              tags.some((t) => t.toLowerCase() === newTag.toLowerCase())
            ) {
              addToast(`Tag "${newTag}" already added.`, "info");
            }
            setInputValue(""); // Clear input field
          }
          // Remove last tag on Backspace if input is empty
          else if (e.key === "Backspace" && !inputValue && tags.length > 0) {
            removeTag(tags.length - 1);
          }
        };

        // Remove a tag by its index
        const removeTag = (indexToRemove) => {
          setTags(tags.filter((_, index) => index !== indexToRemove));
        };

        return (
          <div className="tag-input-container">
            {" "}
            {/* Custom styled container */}
            {/* Display existing tags */}
            {tags.map((tag, index) => (
              <span key={index} className="tag-item">
                {" "}
                {/* Custom styled tag */}
                {tag}
                <button
                  type="button"
                  className="tag-item-remove" // Custom styled remove button
                  onClick={() => removeTag(index)}
                  aria-label={`Remove tag ${tag}`}
                >
                  &times; {/* Multiplication sign as 'x' */}
                </button>
              </span>
            ))}
            {/* Input field for new tags */}
            <input
              type="text"
              value={inputValue}
              onChange={(e) => setInputValue(e.target.value)}
              onKeyDown={handleKeyDown}
              placeholder="Add a tag"
              className="flex-grow border-none outline-none text-sm text-gray-900 dark:text-gray-100 placeholder-gray-500 dark:placeholder-gray-400 bg-transparent"
              aria-label="Tag input"
            />
          </div>
        );
      };

      // --- Add/Edit Recipe Modal Component ---
      const AddRecipeModal = ({
        onClose,
        addRecipe,
        updateRecipe,
        editingRecipe,
        addToast,
      }) => {
        // Define initial empty state structure (memoized for stability)
        const initialFormState = useMemo(
          () => ({
            name: "",
            description: "",
            type: "",
            dietaryTypes: "",
            tags: [],
            // Time fields will be broken into hours/minutes for input
            prepHours: "",
            prepMinutes: "",
            cookHours: "",
            cookMinutes: "",
            additionalHours: "",
            additionalMinutes: "",
            calories: "",
            protein: "",
            carbs: "",
            fat: "",
            servings: "4",
            yield: "", // Added yield field
            ingredients: "",
            directions: "",
            tipsAndTricks: "", // New field for tips and tricks
            image: null,
            video: null,
          }),
          []
        );

        // State for form data, tags, previews, and errors
        const [formData, setFormData] = useState(initialFormState);
        const [tags, setTags] = useState([]); // Tags are managed separately by TagInput
        const [tipsAndTricks, setTipsAndTricks] = useState([]); // Tips and Tricks are managed separately
        const [imagePreview, setImagePreview] = useState(null);
        const [videoPreview, setVideoPreview] = useState(null);
        const [formErrors, setFormErrors] = useState({});

        // Effect to populate form when editingRecipe changes (or reset when adding)
        useEffect(() => {
          if (editingRecipe) {
            // Helper to convert total minutes to hours/minutes for form fields
            const getHours = (totalMins) => Math.floor(totalMins / 60);
            const getMinutes = (totalMins) => totalMins % 60;

            // Populate form with existing recipe data
            setFormData({
              name: editingRecipe.name || "",
              description: editingRecipe.description || "", // Populate description
              type: editingRecipe.type || "",
              dietaryTypes: Array.isArray(editingRecipe.dietaryTypes)
                ? editingRecipe.dietaryTypes.join(", ")
                : "",
              // Populate time fields
              prepHours: getHours(editingRecipe.prepTime || 0),
              prepMinutes: getMinutes(editingRecipe.prepTime || 0),
              cookHours: getHours(editingRecipe.cookTime || 0),
              cookMinutes: getMinutes(editingRecipe.cookTime || 0),
              additionalHours: getHours(editingRecipe.additionalTime || 0),
              additionalMinutes: getMinutes(editingRecipe.additionalTime || 0),

              calories: editingRecipe.calories ?? "", // Use nullish coalescing for potentially undefined numeric fields
              protein: editingRecipe.protein ?? "",
              carbs: editingRecipe.carbs ?? "",
              fat: editingRecipe.fat ?? "",
              servings: editingRecipe.servings ?? "4",
              yield: editingRecipe.yield || "", // Populate yield
              ingredients: Array.isArray(editingRecipe.ingredients)
                ? editingRecipe.ingredients.join("\n")
                : "",
              directions: Array.isArray(editingRecipe.directions)
                ? editingRecipe.directions.join("\n")
                : "",
              tipsAndTricks: Array.isArray(editingRecipe.tipsAndTricks)
                ? editingRecipe.tipsAndTricks.join("\n")
                : "", // Populate tipsAndTricks
              image: editingRecipe.image || null, // Keep existing image/video data URL
              video: editingRecipe.video || null,
            });
            setTags(
              Array.isArray(editingRecipe.tags) ? editingRecipe.tags : []
            ); // Populate tags
            setTipsAndTricks(
              Array.isArray(editingRecipe.tipsAndTricks)
                ? editingRecipe.tipsAndTricks
                : []
            ); // Populate tips and tricks
            setImagePreview(editingRecipe.image || null); // Set previews
            setVideoPreview(editingRecipe.video || null);
          } else {
            // Reset form to initial state when adding a new recipe
            setFormData(initialFormState);
            setTags([]);
            setTipsAndTricks([]); // Reset tips and tricks
            setImagePreview(null);
            setVideoPreview(null);
          }
          setFormErrors({}); // Clear errors when switching between add/edit
        }, [editingRecipe, initialFormState]); // Dependencies

        // Generic handler for input changes
        const handleChange = useCallback(
          (e) => {
            const { name, value } = e.target;
            setFormData((prev) => ({ ...prev, [name]: value }));
            // Clear error message for the field being changed
            if (formErrors[name])
              setFormErrors((prev) => ({ ...prev, [name]: null }));
          },
          [formErrors] // Dependency: formErrors (to clear specific error)
        );

        // Handler for file input changes (image/video)
        const handleFileChange = useCallback((e) => {
          const { name, files } = e.target; // Get name (image/video) and files list
          if (!files || files.length === 0) return; // No file selected
          const file = files[0]; // Get the first file

          // --- File Validation ---
          const MAX_SIZE = 5 * 1024 * 1024; // 5MB size limit
          // Check type
          if (name === "image" && !file.type.startsWith("image/")) {
            setFormErrors((p) => ({ ...p, [name]: "File must be an image." }));
            return;
          }
          if (name === "video" && !file.type.startsWith("video/")) {
            setFormErrors((p) => ({ ...p, [name]: "File must be a video." }));
            return;
          }
          // Check size
          if (file.size > MAX_SIZE) {
            setFormErrors((p) => ({
              ...p,
              [name]: `File too large (Max ${MAX_SIZE / 1024 / 1024}MB).`,
            }));
            return;
          }

          // --- Read File as Data URL ---
          const reader = new FileReader();
          reader.onload = (loadEvent) => {
            // Update form data state with the Data URL
            setFormData((prev) => ({
              ...prev,
              [name]: loadEvent.target.result,
            }));
            // Update preview state
            if (name === "image") setImagePreview(loadEvent.target.result);
            if (name === "video") setVideoPreview(loadEvent.target.result);
            // Clear any previous error for this field
            setFormErrors((prev) => ({ ...prev, [name]: null }));
          };
          reader.onerror = () => {
            // Handle file reading errors
            console.error("Error reading file:", reader.error);
            setFormErrors((prev) => ({
              ...p,
              [name]: "Error reading file.",
            }));
          };
          reader.readAsDataURL(file); // Start reading the file
        }, []); // No dependencies needed

        // Remove image or video
        const removeMedia = useCallback((mediaType) => {
          setFormData((prev) => ({ ...prev, [mediaType]: null })); // Clear from form data
          if (mediaType === "image") setImagePreview(null); // Clear image preview
          if (mediaType === "video") setVideoPreview(null); // Clear video preview
          // Reset the file input element to allow re-selecting the same file
          const fileInput = document.querySelector(`input[name=${mediaType}]`);
          if (fileInput) fileInput.value = "";
        }, []); // No dependencies needed

        // Validate the form fields
        const validateForm = useCallback(() => {
          const errors = {};
          // Required fields
          if (!formData.name.trim()) errors.name = "Recipe name is required.";
          if (!formData.type.trim()) errors.type = "Recipe type is required.";
          if (!formData.ingredients.trim())
            errors.ingredients = "Ingredients are required.";
          if (!formData.directions.trim())
            errors.directions = "Directions are required.";
          // Validate time fields
          const timeFields = ["prep", "cook", "additional"];
          timeFields.forEach((field) => {
            const hours = parseInt(formData[`${field}Hours`]) || 0;
            const minutes = parseInt(formData[`${field}Minutes`]) || 0;
            if (isNaN(hours) || hours < 0) {
              errors[`${field}Hours`] = `Invalid ${field} hours.`;
            }
            if (isNaN(minutes) || minutes < 0 || minutes >= 60) {
              errors[`${field}Minutes`] = `Invalid ${field} minutes (0-59).`;
            }
          });

          // Optional fields (description is optional)
          // Numeric fields (check if NaN or negative, allow 0)
          if (
            isNaN(parseInt(formData.servings)) ||
            parseInt(formData.servings) < 1
          )
            errors.servings = "Servings must be 1 or more.";
          if (formData.calories && isNaN(parseInt(formData.calories)))
            errors.calories = "Calories must be a number.";
          if (formData.protein && isNaN(parseFloat(formData.protein)))
            errors.protein = "Protein must be a number.";
          if (formData.carbs && isNaN(parseFloat(formData.carbs)))
            errors.carbs = "Carbs must be a number.";
          if (formData.fat && isNaN(parseFloat(formData.fat)))
            errors.fat = "Fat must be a number.";
          // Yield validation (optional but if provided, should not be just whitespace)
          if (formData.yield && !formData.yield.trim()) {
            errors.yield = "Yield cannot be just empty spaces.";
          }

          setFormErrors(errors); // Update errors state
          return Object.keys(errors).length === 0; // Return true if no errors
        }, [formData]); // Dependency: formData

        // Handle form submission
        const handleSubmit = useCallback(
          (e) => {
            e.preventDefault(); // Prevent default form submission
            if (!validateForm()) {
              // Validate first
              addToast("Please fix errors before saving.", "error");
              return;
            }

            // Calculate total minutes from hours and minutes inputs
            const calculateTotalMinutes = (hours, minutes) => {
              return (parseInt(hours) || 0) * 60 + (parseInt(minutes) || 0);
            };

            // Prepare recipe data object for saving
            const recipeData = {
              name: formData.name.trim(),
              description: formData.description.trim(), // Add description
              type: formData.type.trim(),
              // Split dietary types string by comma, trim whitespace, filter out empty strings
              dietaryTypes: formData.dietaryTypes
                .split(",")
                .map((t) => t.trim())
                .filter(Boolean),
              tags: tags, // Use the separate tags state
              prepTime: calculateTotalMinutes(
                formData.prepHours,
                formData.prepMinutes
              ),
              cookTime: calculateTotalMinutes(
                formData.cookHours,
                formData.cookMinutes
              ),
              additionalTime: calculateTotalMinutes(
                formData.additionalHours,
                formData.additionalMinutes
              ),

              calories: formData.calories ? parseInt(formData.calories) : null, // Null if empty
              protein: formData.protein ? parseFloat(formData.protein) : null, // Null if empty
              carbs: formData.carbs ? parseFloat(formData.carbs) : null, // Null if empty
              fat: formData.fat ? parseFloat(formData.fat) : null, // Null if empty
              servings: parseInt(formData.servings) || 1, // Default to 1 if NaN or < 1
              yield: formData.yield.trim(), // Save trimmed yield
              // Split ingredients/directions string by newline, trim whitespace, filter out empty lines
              ingredients: formData.ingredients
                .split("\n")
                .map((i) => i.trim())
                .filter(Boolean),
              directions: formData.directions
                .split("\n")
                .map((d) => d.trim())
                .filter(Boolean),
              tipsAndTricks: formData.tipsAndTricks
                .split("\n")
                .map((tip) => tip.trim())
                .filter(Boolean), // Parse tipsAndTricks as an array of strings
              image: formData.image, // Use the Data URL stored in state
              video: formData.video, // Use the Data URL stored in state
            };

            // Call update or add function based on whether editing
            if (editingRecipe) {
              updateRecipe(editingRecipe.id, recipeData);
            } else {
              addRecipe(recipeData);
            }
            // onClose(); // Close modal (handled by add/updateRecipe functions)
          },
          [
            formData,
            tags,
            editingRecipe,
            validateForm,
            addRecipe,
            updateRecipe,
            addToast,
          ]
        ); // Dependencies

        // Close modal if overlay is clicked
        const handleOverlayClick = useCallback(
          (e) => {
            if (e.target === e.currentTarget) onClose();
          },
          [onClose]
        ); // --- Data Lists for Suggestions ---
        const mealTypes = [
          "Appetizers",
          "Burgers",
          "Desserts",
          "Garnishes",
          "Hotdogs/Bratwurst/Etc",
          "Loins",
          "Meatloafs",
          "Pastas",
          "Ribs",
          "Roasts",
          "Salads",
          "Sandwiches",
          "Seafood",
          "Soups/Stews",
          "Spices/Seasoning/Marinades",
          "Steaks",
          "Wraps",
        ].sort();
        const dietaryTypesList = [
          "Gluten-Free",
          "Dairy-Free",
          "Nut-Free",
          "Vegan",
          "Vegetarian",
          "Pescatarian",
          "Keto",
          "Paleo",
          "Low-Carb",
          "Low-Fat",
          "Sugar-Free",
          "Soy-Free",
        ];

        // --- Helper Component for Error Messages ---
        const ErrorMessage = ({ name }) =>
          formErrors[name] ? (
            <p className="text-red-500 text-xs mt-1">{formErrors[name]}</p>
          ) : null;

        // --- Render ---
        return (
          <div
            className="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 p-4"
            onClick={handleOverlayClick} // Close on overlay click
          >
            {/* Modal Content */}
            <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-5 sm:p-6 w-full max-w-3xl max-h-[90vh] overflow-y-auto modal-scale-enter">
              {/* Modal Header */}
              <div className="flex justify-between items-center mb-5 border-b border-gray-200 dark:border-gray-600 pb-3">
                <h2 className="text-xl sm:text-2xl font-semibold text-gray-900 dark:text-gray-100">
                  {editingRecipe ? "Edit Recipe" : "Add New Recipe"}
                </h2>
                <button
                  onClick={onClose}
                  className="text-gray-500 dark:text-gray-400 hover:text-red-500 text-3xl leading-none"
                  aria-label="Close"
                >
                  &times;
                </button>
              </div>

              {/* Form */}
              <form onSubmit={handleSubmit} className="space-y-4" noValidate>
                {/* Name & Type */}
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                  <div>
                    <label
                      htmlFor="name"
                      className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                    >
                      Name *
                    </label>
                    <input
                      type="text"
                      id="name"
                      name="name"
                      value={formData.name}
                      onChange={handleChange}
                      required
                      className={`modal-input ${
                        formErrors.name
                          ? "border-red-500"
                          : "border-gray-300 dark:border-gray-600"
                      }`}
                    />
                    <ErrorMessage name="name" />
                  </div>
                  <div>
                    <label
                      htmlFor="type"
                      className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                    >
                      Type *
                    </label>
                    <input
                      type="text"
                      id="type"
                      name="type"
                      value={formData.type}
                      onChange={handleChange}
                      list="meal-types"
                      required
                      className={`modal-input ${
                        formErrors.type
                          ? "border-red-500"
                          : "border-gray-300 dark:border-gray-600"
                      }`}
                    />
                    <datalist id="meal-types">
                      {mealTypes.map((t) => (
                        <option key={t} value={t} />
                      ))}
                    </datalist>
                    <ErrorMessage name="type" />
                  </div>
                </div>

                {/* Description */}
                <div>
                  <label
                    htmlFor="description"
                    className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                  >
                    Description <span className="text-xs">(optional)</span>
                  </label>
                  <textarea
                    id="description"
                    name="description"
                    value={formData.description}
                    onChange={handleChange}
                    rows="2"
                    className="modal-textarea border-gray-300 dark:border-gray-600"
                  ></textarea>
                  <ErrorMessage name="description" />
                </div>

                {/* Servings & Yield */}
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                  <div>
                    <label
                      htmlFor="servings"
                      className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                    >
                      Servings *
                    </label>
                    <input
                      type="number"
                      id="servings"
                      name="servings"
                      value={formData.servings}
                      onChange={handleChange}
                      min="1"
                      required
                      className={`modal-input ${
                        formErrors.servings
                          ? "border-red-500"
                          : "border-gray-300 dark:border-gray-600"
                      }`}
                    />
                    <ErrorMessage name="servings" />
                  </div>
                  <div>
                    <label
                      htmlFor="yield"
                      className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                    >
                      Yield <span className="text-xs">(e.g., 1.5 cups)</span>
                    </label>
                    <input
                      type="text"
                      id="yield"
                      name="yield"
                      value={formData.yield}
                      onChange={handleChange}
                      className={`modal-input ${
                        formErrors.yield
                          ? "border-red-500"
                          : "border-gray-300 dark:border-gray-600"
                      }`}
                      placeholder="e.g., 8 servings, 2 dozen, 1 gallon"
                    />
                    <ErrorMessage name="yield" />
                  </div>
                </div>

                {/* Dietary Types */}
                <div>
                  <label
                    htmlFor="dietaryTypes"
                    className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                  >
                    Dietary <span className="text-xs">(comma-sep)</span>
                  </label>
                  <input
                    type="text"
                    id="dietaryTypes"
                    name="dietaryTypes"
                    value={formData.dietaryTypes}
                    onChange={handleChange}
                    list="dietary-types"
                    className="modal-input border-gray-300 dark:border-gray-600"
                  />
                  <datalist id="dietary-types">
                    {dietaryTypesList.map((t) => (
                      <option key={t} value={t} />
                    ))}
                  </datalist>
                </div>

                {/* Tags */}
                <div>
                  <label
                    htmlFor="tags"
                    className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                  >
                    Tags <span className="text-xs">(press Enter/comma)</span>
                  </label>
                  <TagInput tags={tags} setTags={setTags} addToast={addToast} />
                  <ErrorMessage name="tags" />
                </div>

                {/* Time Fields (Hours & Minutes) */}
                <fieldset className="border border-gray-300 dark:border-gray-600 p-3 rounded">
                  <legend className="text-sm font-medium px-1 text-gray-700 dark:text-gray-300">
                    Time
                  </legend>
                  <div className="grid grid-cols-1 sm:grid-cols-3 gap-3">
                    {/* Prep Time */}
                    <div>
                      <label className="block text-xs mb-1 text-gray-600 dark:text-gray-400">
                        Prep Time *
                      </label>
                      <div className="flex gap-2">
                        <input
                          type="number"
                          name="prepHours"
                          value={formData.prepHours}
                          onChange={handleChange}
                          placeholder="H"
                          min="0"
                          className={`modal-input-sm w-1/2 ${
                            formErrors.prepHours
                              ? "border-red-500"
                              : "border-gray-300 dark:border-gray-600"
                          }`}
                        />
                        <input
                          type="number"
                          name="prepMinutes"
                          value={formData.prepMinutes}
                          onChange={handleChange}
                          placeholder="M"
                          min="0"
                          max="59"
                          className={`modal-input-sm w-1/2 ${
                            formErrors.prepMinutes
                              ? "border-red-500"
                              : "border-gray-300 dark:border-gray-600"
                          }`}
                        />
                      </div>
                      <ErrorMessage name="prepHours" />
                      <ErrorMessage name="prepMinutes" />
                    </div>
                    {/* Cook Time */}
                    <div>
                      <label className="block text-xs mb-1 text-gray-600 dark:text-gray-400">
                        Cook Time *
                      </label>
                      <div className="flex gap-2">
                        <input
                          type="number"
                          name="cookHours"
                          value={formData.cookHours}
                          onChange={handleChange}
                          placeholder="H"
                          min="0"
                          className={`modal-input-sm w-1/2 ${
                            formErrors.cookHours
                              ? "border-red-500"
                              : "border-gray-300 dark:border-gray-600"
                          }`}
                        />
                        <input
                          type="number"
                          name="cookMinutes"
                          value={formData.cookMinutes}
                          onChange={handleChange}
                          placeholder="M"
                          min="0"
                          max="59"
                          className={`modal-input-sm w-1/2 ${
                            formErrors.cookMinutes
                              ? "border-red-500"
                              : "border-gray-300 dark:border-gray-600"
                          }`}
                        />
                      </div>
                      <ErrorMessage name="cookHours" />
                      <ErrorMessage name="cookMinutes" />
                    </div>
                    {/* Additional Time */}
                    <div>
                      <label className="block text-xs mb-1 text-gray-600 dark:text-gray-400">
                        Additional Time
                      </label>
                      <div className="flex gap-2">
                        <input
                          type="number"
                          name="additionalHours"
                          value={formData.additionalHours}
                          onChange={handleChange}
                          placeholder="H"
                          min="0"
                          className={`modal-input-sm w-1/2 ${
                            formErrors.additionalHours
                              ? "border-red-500"
                              : "border-gray-300 dark:border-gray-600"
                          }`}
                        />
                        <input
                          type="number"
                          name="additionalMinutes"
                          value={formData.additionalMinutes}
                          onChange={handleChange}
                          placeholder="M"
                          min="0"
                          max="59"
                          className={`modal-input-sm w-1/2 ${
                            formErrors.additionalMinutes
                              ? "border-red-500"
                              : "border-gray-300 dark:border-gray-600"
                          }`}
                        />
                      </div>
                      <ErrorMessage name="additionalHours" />
                      <ErrorMessage name="additionalMinutes" />
                    </div>
                  </div>
                </fieldset>

                {/* Nutrition Fields */}
                <fieldset className="border border-gray-300 dark:border-gray-600 p-3 rounded">
                  <legend className="text-sm font-medium px-1 text-gray-700 dark:text-gray-300">
                    Nutrition (per serving, optional)
                  </legend>
                  <div className="grid grid-cols-2 sm:grid-cols-4 gap-3">
                    <div>
                      <label
                        htmlFor="calories"
                        className="block text-xs mb-1 text-gray-600 dark:text-gray-400"
                      >
                        Calories
                      </label>
                      <input
                        type="number"
                        id="calories"
                        name="calories"
                        value={formData.calories}
                        onChange={handleChange}
                        min="0"
                        className={`modal-input-sm ${
                          formErrors.calories
                            ? "border-red-500"
                            : "border-gray-300 dark:border-gray-600"
                        }`}
                      />
                      <ErrorMessage name="calories" />
                    </div>
                    <div>
                      <label
                        htmlFor="protein"
                        className="block text-xs mb-1 text-gray-600 dark:text-gray-400"
                      >
                        Protein (g)
                      </label>
                      <input
                        type="number"
                        id="protein"
                        name="protein"
                        value={formData.protein}
                        onChange={handleChange}
                        min="0"
                        step="0.1"
                        className={`modal-input-sm ${
                          formErrors.protein
                            ? "border-red-500"
                            : "border-gray-300 dark:border-gray-600"
                        }`}
                      />
                      <ErrorMessage name="protein" />
                    </div>
                    <div>
                      <label
                        htmlFor="carbs"
                        className="block text-xs mb-1 text-gray-600 dark:text-gray-400"
                      >
                        Carbs (g)
                      </label>
                      <input
                        type="number"
                        id="carbs"
                        name="carbs"
                        value={formData.carbs}
                        onChange={handleChange}
                        min="0"
                        step="0.1"
                        className={`modal-input-sm ${
                          formErrors.carbs
                            ? "border-red-500"
                            : "border-gray-300 dark:border-gray-600"
                        }`}
                      />
                      <ErrorMessage name="carbs" />
                    </div>
                    <div>
                      <label
                        htmlFor="fat"
                        className="block text-xs mb-1 text-gray-600 dark:text-gray-400"
                      >
                        Fat (g)
                      </label>
                      <input
                        type="number"
                        id="fat"
                        name="fat"
                        value={formData.fat}
                        onChange={handleChange}
                        min="0"
                        step="0.1"
                        className={`modal-input-sm ${
                          formErrors.fat
                            ? "border-red-500"
                            : "border-gray-300 dark:border-gray-600"
                        }`}
                      />
                      <ErrorMessage name="fat" />
                    </div>
                  </div>
                </fieldset>

                {/* Ingredients & Directions */}
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div>
                    <label
                      htmlFor="ingredients"
                      className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                    >
                      Ingredients *{" "}
                      <span className="text-xs">(one per line)</span>
                    </label>
                    <textarea
                      id="ingredients"
                      name="ingredients"
                      value={formData.ingredients}
                      onChange={handleChange}
                      rows="6"
                      required
                      className={`modal-textarea ${
                        formErrors.ingredients
                          ? "border-red-500"
                          : "border-gray-300 dark:border-gray-600"
                      }`}
                    ></textarea>
                    <ErrorMessage name="ingredients" />
                  </div>
                  <div>
                    <label
                      htmlFor="directions"
                      className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                    >
                      Directions *{" "}
                      <span className="text-xs">(one step per line)</span>
                    </label>
                    <textarea
                      id="directions"
                      name="directions"
                      value={formData.directions}
                      onChange={handleChange}
                      rows="6"
                      required
                      className={`modal-textarea ${
                        formErrors.directions
                          ? "border-red-500"
                          : "border-gray-300 dark:border-gray-600"
                      }`}
                    ></textarea>
                    <ErrorMessage name="directions" />
                  </div>
                </div>

                {/* Tips & Tricks */}
                <div>
                  <label
                    htmlFor="tipsAndTricks"
                    className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                  >
                    Tips & Tricks{" "}
                    <span className="text-xs">(one tip per line)</span>
                  </label>
                  <textarea
                    id="tipsAndTricks"
                    name="tipsAndTricks"
                    value={formData.tipsAndTricks}
                    onChange={handleChange}
                    rows="4"
                    className="modal-textarea border-gray-300 dark:border-gray-600"
                    placeholder="e.g., If you don't have fresh basil, use 1 tsp dried basil. This recipe freezes well!"
                  ></textarea>
                </div>

                {/* Image Upload */}
                <div>
                  <label
                    htmlFor="image"
                    className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                  >
                    Image
                  </label>
                  <input
                    type="file"
                    id="image"
                    name="image"
                    accept="image/*"
                    onChange={handleFileChange}
                    className={`block w-full text-sm text-gray-500 file:mr-4 file:py-1.5 file:px-3 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-green-50 dark:file:bg-gray-600 file:text-green-700 dark:file:text-gray-200 hover:file:bg-green-100 dark:hover:file:bg-gray-500 cursor-pointer ${
                      formErrors.image ? "border border-red-500 rounded-md" : ""
                    }`}
                  />
                  <ErrorMessage name="image" />
                  {imagePreview && (
                    <div className="mt-2 relative group w-32 h-32 border border-gray-300 dark:border-gray-600 rounded overflow-hidden">
                      <img
                        src={imagePreview}
                        alt="Preview"
                        className="w-full h-full object-cover"
                      />
                      <button
                        type="button"
                        onClick={() => removeMedia("image")}
                        className="absolute top-1 right-1 bg-red-500 text-white rounded-full w-5 h-5 text-xs flex items-center justify-center opacity-0 group-hover:opacity-100 focus:opacity-100 transition-opacity"
                        aria-label="Remove image"
                      >
                        &times;
                      </button>
                    </div>
                  )}
                </div>

                {/* Video Upload */}
                <div>
                  <label
                    htmlFor="video"
                    className="block text-sm font-medium mb-1 text-gray-700 dark:text-gray-300"
                  >
                    Video
                  </label>
                  <input
                    type="file"
                    id="video"
                    name="video"
                    accept="video/*"
                    onChange={handleFileChange}
                    className={`block w-full text-sm text-gray-500 file:mr-4 file:py-1.5 file:px-3 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 dark:file:bg-gray-600 file:text-blue-700 dark:file:text-gray-200 hover:file:bg-blue-100 dark:hover:file:bg-gray-500 cursor-pointer ${
                      formErrors.video ? "border border-red-500 rounded-md" : ""
                    }`}
                  />
                  <ErrorMessage name="video" />
                  {videoPreview && (
                    <div className="mt-2 relative group max-w-xs border border-gray-300 dark:border-gray-600 rounded overflow-hidden">
                      <video
                        controls
                        className="w-full rounded max-h-40 block bg-black"
                      >
                        <source src={videoPreview} /> No video support.
                      </video>
                      <button
                        type="button"
                        onClick={() => removeMedia("video")}
                        className="absolute top-1 right-1 bg-red-500 text-white rounded-full w-5 h-5 text-xs flex items-center justify-center opacity-0 group-hover:opacity-100 focus:opacity-100 transition-opacity"
                        aria-label="Remove video"
                      >
                        &times;
                      </button>
                    </div>
                  )}
                </div>

                {/* Form Actions */}
                <div className="flex justify-end gap-3 pt-4 border-t border-gray-200 dark:border-gray-600 mt-5">
                  <button
                    type="button"
                    onClick={onClose}
                    className="btn-modal btn-gray"
                  >
                    Cancel
                  </button>
                  <button type="submit" className="btn-modal btn-green">
                    {editingRecipe ? "Save Changes" : "Add Recipe"}
                  </button>
                </div>
              </form>
            </div>
          </div>
        );
      };

      // --- Recipe Details Modal ---
      const RecipeDetailsModal = ({
        recipe,
        onClose,
        addToShoppingList,
        generateRecipePDF,
        deleteRecipe,
        editRecipe,
        toggleFavorite,
        addToast, // Receive addToast prop
      }) => {
        // State for adjusting servings
        const baseServings = recipe?.servings > 0 ? recipe.servings : 1; // Default to 1 if invalid
        const [currentServings, setCurrentServings] = useState(baseServings);
        const servingsMultiplier = currentServings / baseServings;

        // Update servings state, ensuring it's at least 1
        const handleServingsChange = useCallback((value) => {
          setCurrentServings(Math.max(1, parseInt(value) || 1));
        }, []);

        // Calculate total time (memoized)
        const totalTime = useMemo(
          () =>
            parseInt(recipe?.prepTime || 0) +
            parseInt(recipe?.cookTime || 0) +
            parseInt(recipe?.additionalTime || 0),
          [recipe]
        );

        // Close modal if overlay is clicked
        const handleOverlayClick = useCallback(
          (e) => {
            if (e.target === e.currentTarget) onClose();
          },
          [onClose]
        );

        // Don't render if no recipe is provided
        if (!recipe) return null;

        // Calculate and format scaled yield
        const scaledYield = useMemo(() => {
          if (recipe.yield) {
            return formatScaledYield(recipe.yield, servingsMultiplier);
          }
          return null;
        }, [recipe.yield, servingsMultiplier]);

        // Function to generate shareable text content
        const getShareableText = useCallback(() => {
          let text = `Check out this recipe: ${recipe.name}\n\n`;
          if (recipe.description) {
            text += `${recipe.description}\n\n`;
          }
          text += `Servings: ${recipe.servings}\n`;
          text += `Total Time: ${formatMinutesToHoursMinutes(totalTime)}\n\n`;

          if (recipe.ingredients && recipe.ingredients.length > 0) {
            text += "Ingredients:\n";
            recipe.ingredients.forEach((ing) => {
              const { quantity, rest } = parseIngredient(ing);
              const scaledQuantity = quantity
                ? quantity * servingsMultiplier
                : null;
              text += `- ${
                scaledQuantity ? formatQuantity(scaledQuantity) + " " : ""
              }${rest}\n`;
            });
            text += "\n";
          }

          if (recipe.directions && recipe.directions.length > 0) {
            text += "Directions:\n";
            recipe.directions.forEach((dir, index) => {
              text += `${index + 1}. ${dir}\n`;
            });
            text += "\n";
          }

          if (recipe.tipsAndTricks && recipe.tipsAndTricks.length > 0) {
            text += "Tips & Tricks:\n";
            recipe.tipsAndTricks.forEach((tip) => {
              text += `- ${tip}\n`;
            });
            text += "\n";
          }

          text += "Find more recipes with Recipe Manager Pro!";
          return text;
        }, [recipe, totalTime, servingsMultiplier]);

        // Handle sharing the recipe
        const handleShareRecipe = useCallback(async () => {
          const shareData = {
            title: `Recipe: ${recipe.name}`,
            text: getShareableText(),
            // url: window.location.href, // Can add a URL if the app is hosted
          };

          if (navigator.share) {
            try {
              await navigator.share(shareData);
              addToast("Recipe shared successfully!", "success");
            } catch (err) {
              if (err.name === "AbortError") {
                addToast("Sharing cancelled.", "info");
              } else {
                console.error("Error sharing recipe:", err);
                addToast("Failed to share recipe.", "error");
              }
            }
          } else {
            // Fallback for browsers that don't support Web Share API
            try {
              const textToCopy = shareData.text;
              const textarea = document.createElement("textarea");
              textarea.value = textToCopy;
              textarea.style.position = "absolute";
              textarea.style.left = "-9999px";
              document.body.appendChild(textarea);
              textarea.select();
              document.execCommand("copy");
              document.body.removeChild(textarea);
              addToast("Recipe details copied to clipboard!", "info");
            } catch (err) {
              console.error("Failed to copy recipe to clipboard:", err);
              addToast("Failed to copy recipe details.", "error");
            }
          }
        }, [recipe, getShareableText, addToast]);

        // Handle exporting a single recipe
        const handleExportSingleRecipe = useCallback(() => {
          try {
            const dataStr = JSON.stringify(recipe, null, 2); // Stringify the single recipe
            const blob = new Blob([dataStr], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `${recipe.name
              .toLowerCase()
              .replace(/[^a-z0-9]+/g, "-")}-recipe.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            addToast("Recipe exported successfully!", "success");
          } catch (err) {
            console.error("Export single recipe error:", err);
            addToast("Error exporting recipe.", "error");
          }
        }, [recipe, addToast]);

        return (
          <div
            className="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 p-4"
            onClick={handleOverlayClick} // Close on overlay click
          >
            {/* Modal Content */}
            <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-5 sm:p-6 w-full max-w-4xl max-h-[90vh] overflow-y-auto modal-scale-enter">
              {/* Modal Header */}
              <div className="flex justify-between items-start mb-4 border-b border-gray-200 dark:border-gray-600 pb-3 gap-4">
                {/* Title, Description and Badges */}
                <div className="flex-1">
                  <h2 className="text-2xl md:text-3xl font-bold mb-1 text-gray-900 dark:text-gray-100">
                    {escapeHTML(recipe.name)}
                  </h2>
                  {/* Description */}
                  {recipe.description && (
                    <p className="text-sm text-gray-600 dark:text-gray-400 mb-3 italic">
                      {escapeHTML(recipe.description)}
                    </p>
                  )}
                  {/* Badges */}
                  <div className="flex flex-wrap gap-x-2 gap-y-1 items-center text-xs sm:text-sm">
                    <span className="inline-flex items-center gap-1 bg-green-100 dark:bg-green-900 text-green-600 dark:text-green-300 px-2 py-0.5 rounded-full">
                      <i className="fas fa-utensils op-70"></i>{" "}
                      {escapeHTML(recipe.type)}
                    </span>
                    {recipe.dietaryTypes?.map((t) => (
                      <span
                        key={t}
                        className="inline-flex items-center gap-1 bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-300 px-2 py-0.5 rounded-full"
                      >
                        <i className="fas fa-leaf op-70"></i> {escapeHTML(t)}
                      </span>
                    ))}
                    {recipe.tags?.map((tag) => (
                      <span
                        key={tag}
                        className="inline-flex items-center gap-1 bg-purple-100 dark:bg-purple-900 text-purple-700 dark:text-purple-300 px-2 py-0.5 rounded-full"
                      >
                        <i className="fas fa-tag opacity-70"></i>{" "}
                        {escapeHTML(tag)}
                      </span>
                    ))}
                  </div>
                </div>
                {/* Favorite and Close Buttons */}
                <div className="flex items-center gap-2 flex-shrink-0">
                  <button
                    onClick={() => toggleFavorite(recipe.id)}
                    className={`text-2xl p-1 rounded-full ${
                      recipe.isFavorite
                        ? "text-yellow-400 hover:text-yellow-500"
                        : "text-gray-400 hover:text-gray-500 dark:text-gray-500 dark:hover:text-gray-400"
                    }`}
                    title={
                      recipe.isFavorite ? "Remove Favorite" : "Add Favorite"
                    }
                    aria-label={
                      recipe.isFavorite ? "Remove Favorite" : "Add Favorite"
                    }
                  >
                    <i
                      className={`fa-star ${recipe.isFavorite ? "fas" : "far"}`}
                    ></i>
                  </button>
                  <button
                    onClick={onClose}
                    className="text-gray-500 dark:text-gray-400 hover:text-red-500 text-3xl leading-none"
                    aria-label="Close"
                  >
                    &times;
                  </button>
                </div>
              </div>

              {/* Modal Body Grid */}
              <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                {/* Left Column (Image, Video, Servings, Info) */}
                <div className="md:col-span-1 space-y-4">
                  {/* Image */}
                  {recipe.image && (
                    <img
                      src={recipe.image}
                      alt={recipe.name}
                      className="w-full aspect-video object-cover rounded-lg shadow-md border border-gray-200 dark:border-gray-700"
                    />
                  )}
                  {/* Video */}
                  {recipe.video && (
                    <div>
                      <h3 className="text-base font-semibold mb-1 text-gray-800 dark:text-gray-200">
                        Video
                      </h3>
                      <video
                        controls
                        className="w-full rounded-lg shadow-md max-h-48 border border-gray-200 dark:border-gray-700 block bg-black"
                      >
                        <source src={recipe.video} /> No video support.
                      </video>
                    </div>
                  )}
                  {/* Servings Adjuster */}
                  <div className="bg-gray-100 dark:bg-gray-700 p-3 rounded-md shadow-sm">
                    <label
                      htmlFor="servingsAdj"
                      className="font-medium text-sm mb-1.5 block text-gray-700 dark:text-gray-300"
                    >
                      Servings:
                    </label>
                    <div className="flex items-center justify-between gap-2">
                      <span className="text-xs text-gray-600 dark:text-gray-400">
                        Base: {baseServings}
                      </span>
                      <div className="flex items-center gap-1">
                        <button
                          onClick={() =>
                            handleServingsChange(currentServings - 1)
                          }
                          className="adjust-btn"
                          disabled={currentServings <= 1}
                          aria-label="Decrease servings"
                        >
                          -
                        </button>
                        <input
                          type="number"
                          id="servingsAdj"
                          value={currentServings}
                          onChange={(e) => handleServingsChange(e.target.value)}
                          min="1"
                          className="w-12 tc p-1 rounded border border-gray-300 dark:border-gray-500 bg-white dark:bg-gray-600 text-sm focus:outline-none focus:ring-1 focus:ring-green-500 text-gray-900 dark:text-gray-100"
                          aria-label="Current servings"
                        />
                        <button
                          onClick={() =>
                            handleServingsChange(currentServings + 1)
                          }
                          className="adjust-btn"
                          aria-label="Increase servings"
                        >
                          +
                        </button>
                      </div>
                    </div>
                    {/* Display Yield under servings */}
                    {recipe.yield && (
                      <div className="mt-2 text-sm text-gray-700 dark:text-gray-300 flex justify-between items-center border-t border-gray-200 dark:border-gray-600 pt-2">
                        <span className="font-medium">Yield:</span>
                        <span>{scaledYield}</span>
                      </div>
                    )}
                  </div>
                  {/* Quick Info Box */}
                  <div className="bg-gray-100 dark:bg-gray-700 p-3 rounded-md shadow-sm space-y-1.5 text-sm text-gray-700 dark:text-gray-300">
                    <h4 className="font-semibold border-b border-gray-200 dark:border-gray-600 pb-1 mb-1.5 text-gray-800 dark:text-gray-200">
                      Quick Info{" "}
                      <span className="text-xs font-normal text-gray-500">
                        (per serving)
                      </span>
                    </h4>
                    <div className="flex justify-between">
                      <span>Prep:</span>{" "}
                      <span className="font-medium">
                        {formatMinutesToHoursMinutes(recipe.prepTime)}
                      </span>
                    </div>
                    <div className="flex justify-between">
                      <span>Cook:</span>{" "}
                      <span className="font-medium">
                        {formatMinutesToHoursMinutes(recipe.cookTime)}
                      </span>
                    </div>
                    {recipe.additionalTime > 0 && (
                      <div className="flex justify-between">
                        <span>Additional:</span>{" "}
                        <span className="font-medium">
                          {formatMinutesToHoursMinutes(recipe.additionalTime)}
                        </span>
                      </div>
                    )}
                    <div className="flex justify-between font-semibold pt-1 border-t border-gray-200 dark:border-gray-600 mt-1">
                      <span>Total:</span>{" "}
                      <span>{formatMinutesToHoursMinutes(totalTime)}</span>
                    </div>
                    <div className="flex justify-between pt-1 border-t border-gray-200 dark:border-gray-600 mt-1">
                      <span>Calories:</span>{" "}
                      <span className="font-medium">
                        {recipe.calories || "N/A"}
                      </span>
                    </div>
                    <div className="flex justify-between">
                      <span>Protein:</span>{" "}
                      <span className="font-medium">
                        {recipe.protein ? `${recipe.protein}g` : "N/A"}
                      </span>
                    </div>
                    <div className="flex justify-between">
                      <span>Carbs:</span>
                      <span className="font-medium">
                        {recipe.carbs ? `${recipe.carbs}g` : "N/A"}
                      </span>
                    </div>
                    <div className="flex justify-between">
                      <span>Fat:</span>
                      <span className="font-medium">
                        {recipe.fat ? `${recipe.fat}g` : "N/A"}
                      </span>
                    </div>
                  </div>
                </div>

                {/* Right Column (Ingredients, Directions, Tips & Tricks) */}
                <div className="md:col-span-2">
                  {/* Ingredients */}
                  <div className="mb-6">
                    <h3 className="text-xl font-semibold mb-2 flex items-center gap-2 text-gray-900 dark:text-gray-100">
                      <i className="fas fa-list text-green-500"></i>Ingredients{" "}
                      <span className="text-base font-normal text-gray-500">
                        ({currentServings} servings)
                      </span>
                    </h3>
                    <ul className="list-none space-y-1 text-sm border border-gray-200 dark:border-gray-700 rounded-md p-3 bg-gray-50 dark:bg-gray-900 shadow-inner text-gray-800 dark:text-gray-200">
                      {recipe.ingredients?.map((ing, index) => {
                        const { quantity, rest } = parseIngredient(ing);
                        const scaledQuantity = quantity
                          ? quantity * servingsMultiplier
                          : null;
                        return (
                          <li
                            key={index}
                            className="flex items-baseline gap-2 py-1 border-b border-gray-200 dark:border-gray-700 last:border-b-0"
                          >
                            <i className="fas fa-check text-green-500 op-70 text-xs pt-1"></i>
                            <span>
                              {scaledQuantity && (
                                <strong className="mr-1 font-medium">
                                  {formatQuantity(scaledQuantity)}
                                </strong>
                              )}
                              {escapeHTML(rest)}
                            </span>
                          </li>
                        );
                      }) || (
                        <li className="text-gray-500 italic">
                          No ingredients.
                        </li>
                      )}
                    </ul>
                  </div>
                  {/* Directions */}
                  <div className="mb-6">
                    <h3 className="text-xl font-semibold mb-2 flex items-center gap-2 text-gray-900 dark:text-gray-100">
                      <i className="fas fa-shoe-prints text-green-500 -rotate-90 transform"></i>
                      Directions
                    </h3>
                    <ol className="list-none space-y-3">
                      {recipe.directions?.map((dir, index) => (
                        <li
                          key={index}
                          className="flex items-start gap-3 p-3 bg-gray-50 dark:bg-gray-700 rounded-md shadow-sm text-gray-800 dark:text-gray-200"
                        >
                          <span className="bg-green-500 text-white w-6 h-6 rounded-full flex items-center justify-center text-xs font-bold mt-0.5 flex-shrink-0 shadow">
                            {index + 1}
                          </span>
                          <p className="text-sm flex-1">{escapeHTML(dir)}</p>
                        </li>
                      )) || (
                        <li className="text-gray-500 italic p-3 bg-gray-50 dark:bg-gray-700 rounded-md">
                          No directions.
                        </li>
                      )}
                    </ol>
                  </div>
                  {/* Tips & Tricks Section */}
                  {recipe.tipsAndTricks && recipe.tipsAndTricks.length > 0 && (
                    <div className="mt-6">
                      <h3 className="text-xl font-semibold mb-2 flex items-center gap-2 text-gray-900 dark:text-gray-100">
                        <i className="fas fa-lightbulb text-yellow-500"></i>Tips
                        & Tricks
                      </h3>
                      <ul className="list-none space-y-2 p-3 bg-gray-50 dark:bg-gray-700 rounded-md shadow-sm text-gray-800 dark:text-gray-200">
                        {recipe.tipsAndTricks.map((tip, index) => (
                          <li key={index} className="text-sm">
                            <i className="fas fa-caret-right text-yellow-500 mr-2"></i>
                            {escapeHTML(tip)}
                          </li>
                        ))}
                      </ul>
                    </div>
                  )}
                </div>
              </div>

              {/* Modal Footer Actions */}
              <div className="flex flex-wrap gap-3 mt-6 pt-4 border-t border-gray-200 dark:border-gray-600">
                <button
                  onClick={() => generateRecipePDF(recipe)}
                  className="btn-modal bg-pink-500 hover:bg-pink-600 text-white"
                >
                  <i className="fas fa-file-pdf mr-1.5"></i>PDF
                </button>
                <button
                  onClick={() => addToShoppingList(recipe.id)}
                  className="btn-modal btn-gray"
                >
                  <i className="fas fa-cart-plus mr-1.5"></i>Add to List
                </button>
                <button
                  onClick={handleShareRecipe} // New Share button
                  className="btn-modal bg-purple-700 hover:bg-purple-800 text-white"
                >
                  <i className="fas fa-share-alt mr-1.5"></i>Share
                </button>
                {/* New Export Single Recipe Button */}
                <button
                  onClick={handleExportSingleRecipe}
                  className="btn-modal bg-green-500 hover:bg-green-600 text-white"
                  title="Export this recipe"
                >
                  <i className="fas fa-file-export mr-1.5"></i>Export
                </button>
                <button
                  onClick={() => editRecipe(recipe)}
                  className="btn-modal btn-blue"
                >
                  <i className="fas fa-edit mr-1.5"></i>Edit
                </button>
                <button
                  onClick={() => deleteRecipe(recipe.id)}
                  className="btn-modal btn-red ml-auto"
                >
                  <i className="fas fa-trash mr-1.5"></i>Delete
                </button>
              </div>
            </div>
          </div>
        );
      };

      // --- Meal Plan Modal ---
      const MealPlanModal = ({
        mealPlan,
        recipes,
        updateMealPlan,
        removeMealFromPlan,
        addMultipleRecipesToShoppingList,
        onClose,
      }) => {
        // Constants for days and meal times
        const days = [
          "Sunday",
          "Monday",
          "Tuesday",
          "Wednesday",
          "Thursday",
          "Friday",
          "Saturday",
        ];
        const mealTimes = [
          { id: "breakfast", label: "Breakfast", icon: "fa-coffee" },
          { id: "morningSnack", label: "M. Snack", icon: "fa-apple-alt" },
          { id: "lunch", label: "Lunch", icon: "fa-utensils" },
          { id: "afternoonSnack", label: "A. Snack", icon: "fa-cookie-bite" },
          { id: "dinner", label: "Dinner", icon: "fa-drumstick-bite" },
        ];

        // State for recipe selector modal
        const [showRecipeSelector, setShowRecipeSelector] = useState(null); // { day: string, mealTime: string } | null
        const [selectorSearch, setSelectorSearch] = useState("");

        // Memoized list of recipes for the selector, filtered by search
        const filteredRecipesForSelector = useMemo(() => {
          const query = selectorSearch.toLowerCase().trim();
          if (!query)
            return recipes.sort((a, b) => a.name.localeCompare(b.name)); // Sort alphabetically if no query
          return recipes
            .filter(
              (r) =>
                r?.name?.toLowerCase().includes(query) ||
                r?.type?.toLowerCase().includes(query)
            )
            .sort((a, b) => a.name.localeCompare(b.name));
        }, [recipes, selectorSearch]); // Dependencies: recipes list and search query

        // --- Callbacks ---
        // Open recipe selector for a specific slot
        const handleSelectRecipeClick = useCallback((day, mealTimeId) => {
          setShowRecipeSelector({ day, mealTime: mealTimeId });
          setSelectorSearch(""); // Reset search on open
        }, []);

        // Update meal plan when a recipe is selected from the selector
        const handleRecipeSelect = useCallback(
          (recipeId) => {
            if (showRecipeSelector) {
              updateMealPlan(
                showRecipeSelector.day,
                showRecipeSelector.mealTime,
                recipeId
              );
            }
            setShowRecipeSelector(null); // Close selector
          },
          [showRecipeSelector, updateMealPlan]
        );

        // Remove a meal from the plan
        const handleRemoveMeal = useCallback(
          (e, day, mealTimeId) => {
            e.stopPropagation(); // Prevent opening selector when clicking remove button
            removeMealFromPlan(day, mealTimeId);
          },
          [removeMealFromPlan]
        );

        // Close main modal on overlay click
        const handleOverlayClick = useCallback(
          (e) => {
            if (e.target === e.currentTarget) onClose();
          },
          [onClose]
        );

        // Close recipe selector modal on overlay click
        const handleSelectorOverlayClick = useCallback((e) => {
          if (e.target === e.currentTarget) setShowRecipeSelector(null);
        }, []);

        // Get unique recipe IDs for selected days
        const getRecipeIdsForDays = useCallback(
          (daysToGet) => {
            const recipeIds = new Set();
            daysToGet.forEach((day) => {
              if (mealPlan && mealPlan[day]) {
                Object.values(mealPlan[day]).forEach((recipeId) => {
                  if (recipeId) {
                    // Only add if a recipe ID exists
                    recipeIds.add(recipeId);
                  }
                });
              }
            });
            return Array.from(recipeIds);
          },
          [mealPlan] // Dependency: mealPlan
        );

        // Add ingredients for a specific day to the shopping list
        const handleAddDayToList = useCallback(
          (day) => {
            const recipeIds = getRecipeIdsForDays([day]);
            if (recipeIds.length > 0) {
              addMultipleRecipesToShoppingList(recipeIds);
            }
          },
          [getRecipeIdsForDays, addMultipleRecipesToShoppingList]
        );

        // Add ingredients for the entire week to the shopping list
        const handleAddWeekToList = useCallback(() => {
          const recipeIds = getRecipeIdsForDays(days);
          if (recipeIds.length > 0) {
            addMultipleRecipesToShoppingList(recipeIds);
          }
        }, [getRecipeIdsForDays, addMultipleRecipesToShoppingList, days]);

        // --- Render ---
        return (
          <>
            {/* Main Meal Plan Modal */}
            <div
              className="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 p-2 sm:p-4"
              onClick={handleOverlayClick} // Close on overlay click
            >
              <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-4 sm:p-6 w-full max-w-7xl h-[90vh] flex flex-col modal-scale-enter">
                {/* Modal Header */}
                <div className="flex justify-between items-center mb-4 border-b border-gray-200 dark:border-gray-600 pb-3 flex-shrink-0 gap-4">
                  <h2 className="text-xl sm:text-2xl font-bold flex items-center gap-2 text-gray-900 dark:text-gray-100">
                    <i className="fas fa-calendar-alt text-green-500"></i>Weekly
                    Meal Plan
                  </h2>
                  <button
                    onClick={handleAddWeekToList}
                    className="btn-modal btn-green text-xs sm:text-sm ml-auto mr-2"
                    title="Add all ingredients for the week to the shopping list"
                  >
                    <i className="fas fa-cart-plus mr-1"></i> Add Week to List
                  </button>
                  <button
                    onClick={onClose}
                    className="text-gray-500 dark:text-gray-400 hover:text-red-500 text-3xl leading-none"
                    aria-label="Close"
                  >
                    &times;
                  </button>
                </div>

                {/* Meal Plan Grid */}
                <div className="flex-1 overflow-y-auto pb-4 pr-2">
                  <div className="grid grid-cols-1 md:grid-cols-7 gap-3 md:gap-4">
                    {days.map((day) => (
                      <div
                        key={day}
                        className="bg-gray-50 dark:bg-gray-900 p-2 rounded-lg flex flex-col gap-2 shadow-inner"
                      >
                        {/* Day Header */}
                        <div className="flex justify-between items-center mb-1">
                          <h3 className="text-center text-sm font-semibold py-1 flex-grow text-gray-800 dark:text-gray-200">
                            {day}
                          </h3>
                          <button
                            onClick={() => handleAddDayToList(day)}
                            className="text-green-600 dark:text-green-400 hover:text-green-800 dark:hover:text-green-200 text-xs p-1"
                            title={`Add ${day}'s ingredients to shopping list`}
                          >
                            <i className="fas fa-cart-plus"></i>
                          </button>
                        </div>
                        {/* Meal Slots */}
                        <div className="flex flex-col gap-2">
                          {mealTimes.map(({ id, label, icon }) => {
                            const recipeId = mealPlan?.[day]?.[id];
                            const recipe = recipeId
                              ? recipes.find((r) => r?.id === recipeId)
                              : null;
                            return (
                              <div
                                key={id}
                                onClick={() => handleSelectRecipeClick(day, id)}
                                className="bg-white dark:bg-gray-700 rounded-md p-1.5 sm:p-2 shadow-sm flex flex-col min-h-[65px] border border-transparent hover:border-green-400 transition-colors cursor-pointer group relative"
                              >
                                <div className="flex justify-between items-center mb-1 text-xs text-gray-500 dark:text-gray-400">
                                  <span className="flex items-center gap-1 font-medium">
                                    <i
                                      className={`fas ${icon} w-3 tc op-80`}
                                    ></i>{" "}
                                    {label}
                                  </span>
                                  {recipe && (
                                    <button
                                      onClick={(e) =>
                                        handleRemoveMeal(e, day, id)
                                      }
                                      className="text-red-400 hover:text-red-600 text-xs absolute top-1 right-1 bg-white dark:bg-gray-700 rounded-full w-4 h-4 flex items-center justify-center opacity-0 group-hover:opacity-100 focus:opacity-100 transition-opacity"
                                      title="Remove"
                                      aria-label="Remove"
                                    >
                                      <i className="fas fa-times"></i>
                                    </button>
                                  )}
                                </div>
                                <div className="flex-grow flex items-center justify-center text-center">
                                  {recipe ? (
                                    <p
                                      className="text-xs sm:text-sm text-green-600 dark:text-green-400 font-medium leading-tight group-hover:underline line-clamp-3"
                                      title={recipe.name}
                                    >
                                      {escapeHTML(recipe.name)}
                                    </p>
                                  ) : (
                                    <p className="text-[10px] sm:text-xs text-gray-400 dark:text-gray-500 italic group-hover:text-gray-600 dark:group-hover:text-gray-300">
                                      + Add Recipe
                                    </p>
                                  )}
                                </div>
                              </div>
                            );
                          })}
                        </div>
                      </div>
                    ))}

                    {/* --- Quick Add Section (always visible) --- */}
                    <div className="bg-white dark:bg-gray-700 p-2 rounded-lg shadow-inner flex flex-col gap-2">
                      <h3 className="text-center text-sm font-semibold text-gray-800 dark:text-gray-200">
                        Quick Add Recipe
                      </h3>
                      <div className="flex items-center gap-2">
                        <input
                          type="text"
                          placeholder="Recipe name"
                          className="flex-grow p-2 text-sm rounded border border-gray-300 dark:border-gray-600 bg-gray-50 dark:bg-gray-800 focus:outline-none focus:ring-1 focus:ring-green-500"
                          aria-label="Recipe name"
                        />
                        <button
                          className="btn-modal btn-green text-xs"
                          title="Add recipe quickly"
                        >
                          <i className="fas fa-plus"></i>
                        </button>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>

            {/* Recipe Selector Modal (conditionally rendered) */}
            {showRecipeSelector && (
              <div
                className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-[60] p-4"
                onClick={handleSelectorOverlayClick} // Close on overlay click
              >
                <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-4 sm:p-5 w-full max-w-md max-h-[70vh] flex flex-col modal-scale-enter">
                  {/* Selector Header */}
                  <div className="flex justify-between items-center mb-3">
                    <h3 className="text-base sm:text-lg font-semibold text-gray-900 dark:text-gray-100">
                      Select for{" "}
                      <span className="text-green-500">
                        {showRecipeSelector?.day}{" "}
                        {
                          mealTimes.find(
                            (mt) => mt.id === showRecipeSelector?.mealTime
                          )?.label
                        }
                      </span>
                    </h3>
                    <button
                      onClick={() => setShowRecipeSelector(null)}
                      className="text-gray-500 dark:text-gray-400 hover:text-red-500 text-2xl leading-none"
                      aria-label="Close"
                    >
                      &times;
                    </button>
                  </div>
                  {/* Selector Search Input */}
                  <div className="relative mb-3">
                    <input
                      type="search"
                      placeholder="Search recipes..."
                      value={selectorSearch}
                      onChange={(e) => setSelectorSearch(e.target.value)}
                      className="w-full p-2 pl-8 rounded border border-gray-300 dark:border-gray-600 bg-gray-50 dark:bg-gray-700 focus:outline-none focus:ring-1 focus:ring-green-500 text-sm text-gray-900 dark:text-gray-100"
                      aria-label="Search recipes"
                    />
                    <i className="fas fa-search absolute left-2.5 top-1/2 transform -translate-y-1/2 text-gray-400 dark:text-gray-500 text-xs"></i>
                  </div>
                  {/* Recipe List for Selector */}
                  <div className="flex-1 overflow-y-auto space-y-1.5 pr-1">
                    {filteredRecipesForSelector.length > 0 ? (
                      filteredRecipesForSelector.map((recipe) => (
                        <div
                          key={recipe.id}
                          onClick={() => handleRecipeSelect(recipe.id)}
                          role="button"
                          className="bg-gray-50 dark:bg-gray-700 rounded p-2 cursor-pointer hover:bg-green-100 dark:hover:bg-green-900 hover:shadow-sm transition-all duration-150 flex items-center gap-2 border border-transparent hover:border-green-200 dark:hover:border-green-700"
                        >
                          {recipe.image ? (
                            <img
                              src={recipe.image}
                              alt=""
                              className="w-10 h-10 rounded object-cover flex-shrink-0 border border-gray-200 dark:border-gray-600"
                            />
                          ) : (
                            <div className="w-10 h-10 rounded bg-gray-200 dark:bg-gray-600 flex items-center justify-center text-gray-400 text-sm flex-shrink-0 border border-gray-300 dark:border-gray-600">
                              <i className="fas fa-image"></i>
                            </div>
                          )}
                          <div className="flex-grow overflow-hidden">
                            <h4
                              className="text-sm font-medium leading-tight truncate text-gray-800 dark:text-gray-200"
                              title={recipe.name}
                            >
                              {escapeHTML(recipe.name)}
                            </h4>
                            <p className="text-xs text-gray-500 dark:text-gray-400">
                              {escapeHTML(recipe.type)}
                            </p>
                          </div>
                        </div>
                      ))
                    ) : (
                      <div className="text-center text-gray-500 dark:text-gray-400 text-sm py-6">
                        <i className="fas fa-ghost text-2xl mb-2 op-50"></i>
                        <p>No recipes found.</p>
                      </div>
                    )}
                  </div>
                </div>
              </div>
            )}
          </>
        );
      };

      // --- Shopping List Modal ---
      const ShoppingListModal = ({
        shoppingList,
        toggleShoppingItem,
        clearShoppingList,
        addToast,
        onClose,
      }) => {
        // State to control visibility of checked items
        const [showChecked, setShowChecked] = useState(true);

        // Memoized grouping of shopping list items by recipe name
        const groupedByRecipe = useMemo(() => {
          const groups = {};
          if (!Array.isArray(shoppingList)) return groups; // Handle empty/invalid list

          shoppingList.forEach((item) => {
            if (!item || typeof item !== "object") return; // Skip invalid items
            const recipeName = item.recipeName || "Manually Added"; // Group items without a recipe

            // Ensure normalizedText exists on the item for consistency
            const normalized =
              item.normalizedText || normalizeIngredient(item.text);
            if (!normalized) return; // Skip if no normalized text

            if (!groups[recipeName]) {
              // Initialize group if it doesn't exist
              groups[recipeName] = {
                id: item.recipeId || "manual",
                name: recipeName,
                items: [],
              };
            }
            // Add item with normalized text
            groups[recipeName].items.push({
              ...item,
              normalizedText: normalized,
            });
          });

          // Sort items within each group alphabetically by original text
          Object.values(groups).forEach((group) => {
            group.items.sort((a, b) => a.text.localeCompare(b.text));
          });

          return groups;
        }, [shoppingList]); // Dependency: shoppingList

        // Memoized list of common ingredients (appearing in more than one recipe)
        const commonIngredientsData = useMemo(() => {
          const normalizedDetails = {}; // Store details keyed by normalized text

          shoppingList.forEach((item) => {
            const norm = item.normalizedText;
            if (!norm) return; // Skip if no normalized text

            if (!normalizedDetails[norm]) {
              // Initialize if first time seeing this normalized ingredient
              normalizedDetails[norm] = {
                display_name: capitalizeFirstLetter(norm), // Use capitalized normalized text for display
                checked: item.checked, // Initial checked state
                recipeSources: new Set(), // Track unique recipe sources
                instanceCount: 0, // Total count of this normalized item
                uncheckedCount: 0, // Count of unchecked instances
              };
            }

            // Update details
            normalizedDetails[norm].recipeSources.add(
              item.recipeName || "Manually Added"
            );
            normalizedDetails[norm].instanceCount++;
            if (!item.checked) normalizedDetails[norm].uncheckedCount++;
            // Update the overall checked state for the group
            // If *any* instance is unchecked, the group is considered unchecked
            if (!item.checked) {
              normalizedDetails[norm].checked = false;
            } else if (normalizedDetails[norm].uncheckedCount === 0) {
              // Only mark as checked if ALL instances are checked
              normalizedDetails[norm].checked = true;
            }
          });

          // Filter for items appearing in more than one source and format output
          const commonList = Object.entries(normalizedDetails)
            .filter(([norm, details]) => details.recipeSources.size > 1) // Only items from >1 source
            .map(([norm, details]) => ({
              normalizedText: norm,
              text: details.display_name, // Display name (capitalized normalized)
              checked: details.uncheckedCount === 0, // Considered 'checked' if all instances are checked
              recipeSources: Array.from(details.recipeSources), // List of source recipes
            }));

          return commonList.sort((a, b) => a.text.localeCompare(b.text)); // Sort alphabetically
        }, [shoppingList]); // Dependency: shoppingList

        // Memoized list of recipe groups to display, filtered by showChecked state
        const displayRecipeGroups = useMemo(() => {
          return Object.values(groupedByRecipe)
            .map((group) => ({
              ...group,
              // Filter items within the group based on showChecked state
              items: showChecked
                ? group.items
                : group.items.filter((item) => !item.checked),
            }))
            .filter((group) => group.items.length > 0) // Only include groups with visible items
            .sort((a, b) => a.name.localeCompare(b.name)); // Sort groups alphabetically
        }, [groupedByRecipe, showChecked]); // Dependencies: grouped data and showChecked state

        // Memoized list of common ingredients to display, filtered by showChecked state
        const displayCommonIngredients = useMemo(() => {
          return showChecked
            ? commonIngredientsData
            : commonIngredientsData.filter((item) => !item.checked);
        }, [commonIngredientsData, showChecked]); // Dependencies: common ingredients data and showChecked state

        // --- Callbacks ---
        // Generate formatted text for clipboard
        const getFormattedListText = useCallback(() => {
          let listText = "Shopping List\n==============\n\n";
          const itemsToInclude = showChecked
            ? shoppingList
            : shoppingList.filter((item) => !item.checked);
          if (itemsToInclude.length === 0) return ""; // Return empty if nothing to copy

          const outputGroups = {};
          itemsToInclude.forEach((item) => {
            const recipeName = item.recipeName || "Other Items";
            if (!outputGroups[recipeName]) outputGroups[recipeName] = [];
            // Add item with checkbox marker and original text
            outputGroups[recipeName].push(
              `${item.checked ? "[x]" : "[ ]"} ${item.text}`
            );
          });

          // Sort group names, putting "Other Items" last
          const sortedGroupNames = Object.keys(outputGroups).sort((a, b) => {
            if (a === "Other Items") return 1;
            if (b === "Other Items") return -1;
            return a.localeCompare(b);
          });

          // Build the final text string
          sortedGroupNames.forEach((groupName) => {
            listText += `--- ${groupName} ---\n`;
            outputGroups[groupName]
              .sort((a, b) => a.substring(4).localeCompare(b.substring(4))) // Sort items alphabetically within group (ignore checkbox)
              .forEach((itemText) => {
                listText += `${itemText}\n`;
              });
            listText += "\n";
          });

          return listText.trim();
        }, [shoppingList, showChecked]); // Dependencies

        // Copy formatted list to clipboard
        const copyToClipboard = useCallback(async () => {
          // Replaced navigator.clipboard.writeText with document.execCommand('copy') for better iFrame compatibility
          try {
            const listText = getFormattedListText();
            if (!listText) {
              addToast("List is empty or all items hidden.", "info");
              return;
            }
            const textarea = document.createElement("textarea");
            textarea.value = listText;
            textarea.style.position = "absolute";
            textarea.style.left = "-9999px";
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand("copy");
            document.body.removeChild(textarea);
            addToast("List copied to clipboard!", "success");
          } catch (err) {
            console.error("Failed to copy list:", err);
            addToast("Failed to copy list.", "error");
          }
        }, [getFormattedListText, addToast]); // Dependencies

        // Toggle a single item (wrapper for toggleShoppingItem)
        const handleToggleItem = useCallback(
          (itemId) => {
            toggleShoppingItem(itemId, null); // Pass null for normalizedText
          },
          [toggleShoppingItem]
        );

        // Toggle all instances of a common item (wrapper for toggleShoppingItem)
        const handleToggleCommonItem = useCallback(
          (normalizedText) => {
            toggleShoppingItem(null, normalizedText); // Pass null for itemId
          },
          [toggleShoppingItem]
        );

        // Close modal on overlay click
        const handleOverlayClick = useCallback(
          (e) => {
            if (e.target === e.currentTarget) onClose();
          },
          [onClose]
        );

        // Clear the entire list with confirmation
        const handleClearList = useCallback(() => {
          if (
            shoppingList.length > 0 &&
            window.confirm(
              "Are you sure you want to clear the entire shopping list? This cannot be undone."
            )
          ) {
            clearShoppingList();
          } else if (shoppingList.length === 0) {
            addToast("Shopping list is already empty.", "info");
          }
        }, [shoppingList, clearShoppingList, addToast]);

        // Memoized count of total unchecked items
        const totalUncheckedItems = useMemo(
          () => shoppingList.filter((item) => !item.checked).length,
          [shoppingList]
        );

        // --- Render ---
        return (
          <div
            className="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 p-4"
            onClick={handleOverlayClick} // Close on overlay click
          >
            {/* Modal Content */}
            <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-4 sm:p-6 w-full max-w-2xl max-h-[90vh] flex flex-col modal-scale-enter">
              {/* Modal Header */}
              <div className="flex justify-between items-center mb-4 border-b border-gray-200 dark:border-gray-600 pb-3">
                <h2 className="text-xl sm:text-2xl font-bold flex items-center gap-2 text-gray-900 dark:text-gray-100">
                  <i className="fas fa-shopping-cart text-green-500"></i>{" "}
                  Shopping List ({totalUncheckedItems} items)
                </h2>
                <button
                  onClick={onClose}
                  className="text-gray-500 dark:text-gray-400 hover:text-red-500 text-3xl leading-none"
                  aria-label="Close"
                >
                  &times;
                </button>
              </div>

              {/* Controls (Show Purchased, Copy, Clear) */}
              <div className="flex justify-between items-center mb-4 gap-4 flex-wrap">
                <label className="flex items-center gap-1.5 cursor-pointer text-sm order-2 sm:order-1 text-gray-700 dark:text-gray-300">
                  <input
                    type="checkbox"
                    checked={showChecked}
                    onChange={() => setShowChecked((p) => !p)}
                    className="w-4 h-4 mt-0.5 rounded text-green-500 focus:ring-offset-0 focus:ring-green-500 border-gray-300 dark:border-gray-600"
                  />{" "}
                  Show purchased
                </label>
                <div className="flex gap-2 order-3 sm:order-2">
                  <button
                    onClick={copyToClipboard}
                    className="btn-modal btn-gray text-xs"
                    title="Copy list to clipboard"
                    disabled={shoppingList.length === 0}
                  >
                    <i className="fas fa-copy mr-1"></i> Copy
                  </button>
                </div>
                <button
                  onClick={handleClearList}
                  className="btn-modal btn-red text-xs order-1 sm:order-3 ml-auto sm:ml-0"
                  disabled={shoppingList.length === 0}
                >
                  <i className="fas fa-trash mr-1"></i>Clear List
                </button>
              </div>

              {/* Shopping List Items Area */}
              <div className="flex-1 overflow-y-auto pr-2 space-y-4">
                {/* Show message if list is empty or all items are hidden */}
                {displayRecipeGroups.length === 0 &&
                displayCommonIngredients.length === 0 ? (
                  <div className="text-center text-gray-500 dark:text-gray-400 py-8 px-4">
                    <i className="fas fa-clipboard-list text-4xl mb-3 opacity-50"></i>
                    <p className="font-semibold">Shopping list is empty</p>
                    <p className="text-sm">
                      {showChecked
                        ? "Add ingredients from recipes!"
                        : "All items purchased."}
                    </p>
                  </div>
                ) : (
                  <>
                    {/* Display common ingredients */}
                    {displayCommonIngredients.length > 0 && (
                      <div className="pb-3 mb-3 border-b border-gray-200 dark:border-gray-600">
                        <h3 className="text-sm font-semibold mb-1 text-blue-600 dark:text-blue-400">
                          Common Ingredients
                        </h3>
                        <ul className="space-y-1 mt-1">
                          {displayCommonIngredients.map((item) => (
                            <li
                              key={item.normalizedText}
                              className={`p-1 rounded flex items-start gap-2 transition-opacity duration-200 ${
                                item.checked
                                  ? "opacity-50 hover:opacity-70"
                                  : "hover:bg-gray-50 dark:hover:bg-gray-700"
                              }`}
                            >
                              <input
                                type="checkbox"
                                checked={item.checked}
                                onChange={() =>
                                  handleToggleCommonItem(item.normalizedText)
                                }
                                className="w-4 h-4 mt-0.5 rounded text-green-500 focus:ring-offset-0 focus:ring-green-500 border-gray-300 dark:border-gray-500 flex-shrink-0 cursor-pointer"
                                aria-label={`Mark all '${item.text}' as ${
                                  item.checked ? "not purchased" : "purchased"
                                }`}
                              />
                              <span
                                className={`block leading-tight text-sm font-medium ${
                                  item.checked
                                    ? "line-through text-gray-500 dark:text-gray-400"
                                    : "text-gray-800 dark:text-gray-100"
                                }`}
                              >
                                {/* Display capitalized normalized name */}
                                {escapeHTML(item.text)}
                                <span className="text-xs text-gray-400 dark:text-gray-500 ml-2 font-normal">
                                  ({item.recipeSources.join(", ")})
                                </span>
                              </span>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}

                    {/* Display items grouped by recipe */}
                    {displayRecipeGroups.length > 0 && (
                      <div>
                        <h3 className="text-sm font-semibold mb-1 text-green-600 dark:text-green-400 border-b border-green-200 dark:border-green-700 pb-0.5">
                          Ingredients by Recipe
                        </h3>
                        <ul className="space-y-1 mt-1">
                          {displayRecipeGroups.map((group) => (
                            <li key={group.id}>
                              <h4 className="text-sm font-medium text-gray-700 dark:text-gray-300 mt-2 mb-1">
                                {escapeHTML(group.name)}
                              </h4>
                              <ul className="space-y-0.5 pl-4">
                                {group.items.map((item) => (
                                  <li
                                    key={item.id}
                                    className={`flex items-start gap-2 transition-opacity duration-200 ${
                                      item.checked
                                        ? "opacity-50 hover:opacity-70"
                                        : "hover:bg-gray-50 dark:hover:bg-gray-700"
                                    }`}
                                  >
                                    <input
                                      type="checkbox"
                                      checked={item.checked}
                                      onChange={() => handleToggleItem(item.id)}
                                      className="w-4 h-4 mt-0.5 rounded text-green-500 focus:ring-offset-0 focus:ring-green-500 border-gray-300 dark:border-gray-500 flex-shrink-0 cursor-pointer"
                                      aria-label={`Mark ${item.text} as ${
                                        item.checked
                                          ? "not purchased"
                                          : "purchased"
                                      }`}
                                    />
                                    <span
                                      className={`block leading-tight text-sm ${
                                        item.checked
                                          ? "line-through text-gray-500 dark:text-gray-400"
                                          : "text-gray-800 dark:text-gray-100"
                                      }`}
                                    >
                                      {escapeHTML(item.text)}
                                    </span>
                                  </li>
                                ))}
                              </ul>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </>
                )}
              </div>
            </div>
          </div>
        );
      };

      // --- Footer Component ---
      const Footer = () => {
        const currentYear = new Date().getFullYear();
        const emailAddress = "BarrTechSolutions@gmail.com";

        return (
          <footer className="bg-gray-200 dark:bg-gray-800 text-gray-700 dark:text-gray-300 py-4 text-center text-sm mt-8">
            <div className="max-w-7xl mx-auto px-4">
              <p>
                &copy; {currentYear} BarrTech Solutions. All rights reserved.
              </p>
              <p className="mt-1">
                Contact:{" "}
                <a
                  href={`mailto:${emailAddress}`}
                  className="text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-green-500"
                >
                  {emailAddress}
                </a>
              </p>
            </div>
          </footer>
        );
      };

      // --- Mount React App ---
      const rootElement = document.getElementById("root");
      if (rootElement) {
        // Use React.createRoot for React 18+
        const reactRoot = ReactDOM.createRoot(rootElement);
        reactRoot.render(<App />);
      } else {
        console.error("Root element not found! React app cannot be mounted.");
      }
    </script>
  </body>
</html>
